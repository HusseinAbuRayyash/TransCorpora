<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TransCorpora - Corpus Creation and Analysis for Translation Archival Research</title>
  <!-- Core Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  
<!-- Document Processing Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
  <script>
      window.onload = function() {
          if (typeof pdfjsLib !== 'undefined') {
              pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
              console.log("PDF.js initialized successfully");
          } else {
              console.error("PDF.js library failed to load");
          }
      };
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
  
  <!-- Visualization Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.2/d3.min.js"></script>
  
  <!-- UI Enhancement Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Lora:wght@400;700&display=swap" rel="stylesheet">
  
  <style>
    /* Theme Variables - Light Mode (Default) */
    :root {
      --font-sans: 'Inter', sans-serif;
      --font-serif: 'Lora', serif;
      --primary-color: #1a3d5c;
      --secondary-color: #2980b9;
      --accent-color: #f0f7ff;
      --text-color: #333;
      --light-text: #666;
      --border-color: #ddd;
      --success-color: #27ae60;
      --warning-color: #e67e22;
      --error-color: #e74c3c;
      --background-color: #f7f9fc;
      --card-background: white;
      --header-background: #1a3d5c;
      --header-text: white;
      --footer-background: #1a3d5c;
      --footer-text: white;
      --modal-background: #fefefe;
      --console-background: #2c3e50;
      --console-text: #ecf0f1;
      --settings-toggle: #f5f5f5;
      --settings-content: #f9f9f9;
      --timeline-bar: #8bc6fc;
      --timeline-bar-hover: #3498db;
      --network-node: #3498db;
      --network-link: #95a5a6;
      --tooltip-background: rgba(0, 0, 0, 0.8);
      --tooltip-text: white;
      --chart-colors: #3498db, #2ecc71, #e74c3c, #f39c12, #9b59b6, #1abc9c, #34495e, #e67e22;
      --scrollbar-thumb: #b0b0b0;
      --scrollbar-track: #f1f1f1;
      --spacing-sm: 8px;
      --spacing-md: 16px;
      --spacing-lg: 24px;
      --border-radius-lg: 12px;
    }
    
    /* Dark Mode Theme Variables */
    [data-theme="dark"] {
      --primary-color: #2c3e50;
      --secondary-color: #3498db;
      --accent-color: #1c2331;
      --text-color: #ecf0f1;
      --light-text: #bdc3c7;
      --border-color: #34495e;
      --success-color: #2ecc71;
      --warning-color: #f39c12;
      --error-color: #e74c3c;
      --background-color: #121212;
      --card-background: #1e1e1e;
      --header-background: #2c3e50;
      --header-text: #ecf0f1;
      --footer-background: #2c3e50;
      --footer-text: #ecf0f1;
      --modal-background: #1e1e1e;
      --console-background: #1a1a1a;
      --console-text: #ecf0f1;
      --settings-toggle: #2c3e50;
      --settings-content: #1c2331;
      --timeline-bar: #3498db;
      --timeline-bar-hover: #2980b9;
      --network-node: #3498db;
      --network-link: #7f8c8d;
      --tooltip-background: rgba(236, 240, 241, 0.8);
      --tooltip-text: #121212;
      --chart-colors: #3498db, #2ecc71, #e74c3c, #f39c12, #9b59b6, #1abc9c, #7f8c8d, #e67e22;
      --scrollbar-thumb: #555;
      --scrollbar-track: #2c3e50;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    
    body {
      font-family: var(--font-sans);
      line-height: 1.6;
      color: var(--text-color);
      background-color: var(--background-color);
      padding: 0;
      margin: 0;
    }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 12px;
      height: 12px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
    }
    
    ::-webkit-scrollbar-thumb {
      background-color: var(--scrollbar-thumb);
      border-radius: 6px;
      border: 3px solid var(--scrollbar-track);
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--secondary-color);
    }
    
    /* Header Styles */
    .header {
      background: var(--header-background);
      color: var(--header-text);
      text-align: center;
      padding: 2rem 0;
      margin-bottom: 1rem;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      position: relative;
    }
    
    /* Theme Toggle Switch */
    .theme-switch-wrapper {
      position: absolute;
      top: 1rem;
      right: 2rem;
      display: flex;
      align-items: center;
    }
    
    .theme-switch {
      display: inline-block;
      height: 24px;
      position: relative;
      width: 48px;
    }
    
    .theme-switch input {
      display: none;
    }
    
    .slider {
      background-color: #ccc;
      bottom: 0;
      cursor: pointer;
      left: 0;
      position: absolute;
      right: 0;
      top: 0;
      transition: .4s;
      border-radius: 34px;
    }
    
    .slider:before {
      background-color: white;
      bottom: 4px;
      content: "";
      height: 16px;
      left: 4px;
      position: absolute;
      transition: .4s;
      width: 16px;
      border-radius: 50%;
    }
    
    input:checked + .slider {
      background-color: var(--secondary-color);
    }
    
    input:checked + .slider:before {
      transform: translateX(24px);
    }
    
    .theme-label {
      margin-right: 10px;
      font-size: 0.9rem;
      color: var(--header-text);
    }
    
    /* Focus Styles for Accessibility */
    button:focus, input:focus, select:focus, .tab-button:focus {
      outline: 3px solid var(--secondary-color);
      outline-offset: 2px;
    }

    /* Keyboard Shortcuts Button */
    .keyboard-shortcuts-btn {
      position: absolute;
      top: 1rem;
      left: 2rem;
      background-color: transparent;
      color: var(--header-text);
      border: 1px solid var(--header-text);
      padding: 5px 10px;
      font-size: 0.8rem;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .keyboard-shortcuts-btn:hover {
      background-color: rgba(255,255,255,0.1);
    }
    
    h1, h2, h3, h4, h5 {
      font-family: var(--font-serif);
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    h1 {
      font-size: 2.5rem;
    }
    
    h2 {
      font-size: 1.8rem;
      color: var(--primary-color);
    }
    
    h3 {
      font-size: 1.4rem;
      color: var(--primary-color);
    }
    
    h4 {
      font-size: 1.2rem;
      color: var(--primary-color);
    }
    
    h5 {
      font-size: 1.1rem;
      color: var(--primary-color);
    }
    
    .subtitle {
      font-style: italic;
      font-weight: 300;
      font-size: 1.1rem;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
    }
    
    .card {
      background-color: var(--card-background);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      padding: 30px;
      margin-bottom: 30px;
    }
    
    .section-title {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .section-title span {
      background-color: var(--primary-color);
      color: white;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 15px;
      font-weight: bold;
    }
    
    /* Form Controls */
    label {
      display: block;
      margin-bottom: 10px;
      font-weight: 600;
    }
    
    input, select, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: var(--font-sans);
      margin-bottom: 15px;
      background-color: var(--card-background);
      color: var(--text-color);
    }
    
    input[type="checkbox"], input[type="radio"] {
      width: auto;
      margin-right: 8px;
    }
    
    /* Button Styles */
    button {
      background-color: var(--secondary-color);
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      font-family: var(--font-sans);
      font-weight: 600;
      transition: background-color 0.3s, transform 0.2s;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    
    button:hover {
      background-color: var(--primary-color);
      transform: translateY(-2px);
    }
    
    button:active {
      transform: translateY(1px);
    }
    
    button:disabled {
      background-color: #b2b2b2;
      cursor: not-allowed;
      transform: none;
    }
    
    button.icon-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
    }
    
    button.icon-button svg {
      margin-right: 8px;
    }
    
    /* Progress Bar */
    .progress {
      width: 100%;
      height: 10px;
      background-color: var(--border-color);
      border-radius: 5px;
      overflow: hidden;
      margin: 15px 0;
    }
    
    .progress-bar {
      height: 100%;
      background-color: var(--success-color);
      width: 0%;
      transition: width 0.3s;
    }
    
    .progress-label {
      text-align: center;
      font-size: 14px;
      color: var(--light-text);
      margin-top: 5px;
    }
    
    .status {
      font-style: italic;
      margin: 15px 0;
      color: var(--light-text);
    }
    
    /* Results Styles */
    .results {
      margin-top: 30px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 14px;
    }
    
    th {
      background-color: var(--primary-color);
      color: white;
      padding: 12px 8px;
      text-align: left;
      font-weight: 600;
    }
    
    td {
      padding: 10px 8px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
    }
    
    tr:hover {
      background-color: rgba(0,0,0,0.03);
    }
    
    [data-theme="dark"] tr:hover {
      background-color: rgba(255,255,255,0.03);
    }
    
    .help-text {
      font-size: 14px;
      color: var(--light-text);
      margin: 5px 0 15px;
    }
    
    .example-box {
      background-color: var(--accent-color);
      border-left: 3px solid var(--secondary-color);
      padding: 15px;
      margin: 15px 0;
      font-size: 0.9em;
    }
    
    .info-box {
      background-color: var(--accent-color);
      padding: 20px;
      border-radius: 5px;
      margin: 20px 0;
      border-left: 4px solid var(--secondary-color);
    }
    
    /* Console Styles */
    .log-console {
      background-color: var(--console-background);
      color: var(--console-text);
      padding: 15px;
      border-radius: 5px;
      font-family: monospace;
      height: 200px;
      overflow-y: auto;
      font-size: 14px;
      margin: 20px 0;
    }
    
    /* Download Button Styles */
    .download-btn {
      display: inline-block; 
      background-color: var(--success-color); 
      color: white; 
      padding: 10px 20px; 
      text-decoration: none; 
      border-radius: 4px; 
      margin: 15px 10px 15px 0;
      font-weight: 600;
      transition: background-color 0.3s, transform 0.2s;
    }
    
    .download-btn:hover {
      background-color: #219653;
      transform: translateY(-2px);
    }
    
    .download-btn:active {
      transform: translateY(1px);
    }
    
    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 100;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.5);
    }
    
    .modal-content {
      background-color: var(--modal-background);
      margin: 5% auto;
      padding: 25px;
      border: 1px solid var(--border-color);
      width: 85%;
      max-width: 900px;
      border-radius: 8px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    }
    
    .close {
      color: var(--light-text);
      float: right;
      font-size: 28px;
      font-weight: bold;
      line-height: 0.8;
      cursor: pointer;
      transition: color 0.3s;
    }
    
    .close:hover,
    .close:focus {
      color: var(--text-color);
    }
    
    /* Settings Toggle */
    .settings-toggle {
      background-color: var(--settings-toggle);
      padding: 12px 15px;
      margin-bottom: 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 600;
      color: var(--primary-color);
      transition: background-color 0.3s;
      user-select: none;
    }
    
    .settings-toggle:hover {
      background-color: var(--border-color);
    }
    
    .settings-toggle::after {
      content: " ‚ñº";
      font-size: 0.8em;
    }
    
    .settings-toggle.active::after {
      content: " ‚ñ≤";
      font-size: 0.8em;
    }
    
    .settings-content {
      display: none;
      padding: 20px;
      background-color: var(--settings-content);
      border-radius: 5px;
      margin-bottom: 20px;
    }
    
    .settings-content.show {
      display: block;
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    @media (max-width: 768px) {
      .settings-grid {
        grid-template-columns: 1fr;
      }
      
      .theme-switch-wrapper {
        position: static;
        justify-content: center;
        margin-top: 1rem;
      }
      
      .keyboard-shortcuts-btn {
        position: static;
        display: block;
        margin: 1rem auto;
      }
    }
    
    /* Footer Styles */
    .footer {
      background-color: var(--footer-background);
      color: var(--footer-text);
      text-align: center;
      padding: 20px 0;
      margin-top: 40px;
      font-size: 0.9rem;
    }
    
    /* Table Row Styles */
    .clickable-row {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    /* Badge Styles */
    .review-type-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .type-formal-review {
      background-color: #e1f5fe;
      color: #0277bd;
    }
    
    .type-news {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .type-announcement {
      background-color: #fff8e1;
      color: #ff8f00;
    }
    
    .type-notes {
      background-color: #f3e5f5;
      color: #7b1fa2;
    }
    
    .type-other {
      background-color: #f5f5f5;
      color: #616161;
    }
    
    [data-theme="dark"] .type-formal-review {
      background-color: #01579b;
      color: #e1f5fe;
    }
    
    [data-theme="dark"] .type-news {
      background-color: #1b5e20;
      color: #e8f5e9;
    }
    
    [data-theme="dark"] .type-announcement {
      background-color: #e65100;
      color: #fff8e1;
    }
    
    [data-theme="dark"] .type-notes {
      background-color: #4a148c;
      color: #f3e5f5;
    }
    
    [data-theme="dark"] .type-other {
      background-color: #424242;
      color: #f5f5f5;
    }
    
    /* API Section Styles */
    .api-section {
      background-color: #fff9e6;
      border-left: 4px solid #f39c12;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    [data-theme="dark"] .api-section {
      background-color: #332d1a;
    }
    
    /* URL Styles */
    .url-link {
      color: var(--secondary-color);
      text-decoration: underline;
      cursor: pointer;
    }
    
    .url-link:hover {
      text-decoration: none;
    }
    
    /* Tab System */
    .tab-container {
      margin: 20px 0;
    }
    
    .tab-nav {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      overflow-x: auto;
      scrollbar-width: thin;
      margin-bottom: 20px;
    }
    
    .tab-button {
      padding: 10px 20px;
      margin-right: 5px;
      background: transparent;
      color: var(--text-color);
      border: none;
      border-bottom: 3px solid transparent;
      border-radius: 4px 4px 0 0;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .tab-button:hover {
      background-color: rgba(0,0,0,0.03);
      transform: none;
    }
    
    [data-theme="dark"] .tab-button:hover {
      background-color: rgba(255,255,255,0.03);
    }
    
    .tab-button.active {
      border-bottom: 3px solid var(--secondary-color);
      background-color: rgba(0,0,0,0.03);
    }
    
    [data-theme="dark"] .tab-button.active {
      background-color: rgba(255,255,255,0.03);
    }
    
    .tab-content {
      display: none;
      padding: 15px;
      border: 1px solid var(--border-color);
      border-top: none;
      border-radius: 0 0 4px 4px;
      background-color: var(--card-background);
    }
    
    .tab-content.active {
      display: block;
      animation: fadeIn 0.5s;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* Data Analysis and Visualization Styles */
    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .stat-card {
      background-color: var(--card-background);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      text-align: center;
      transition: transform 0.3s;
      cursor: move;
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
    }
    
    .stat-number {
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary-color);
      margin: 10px 0;
    }
    
    .stat-label {
      font-size: 1rem;
      color: var(--light-text);
    }
    
    /* Charts and Graphs */
    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
      margin: 30px 0;
    }
    
    .small-chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    
    .timeline-container {
      overflow-x: auto;
      margin: 20px 0;
      padding: 20px 0;
    }
    
    .timeline {
      position: relative;
      height: 300px;
    }
    
    .network-container {
      height: 500px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      margin: 20px 0;
    }
    
    /* Search & Filter Bar */
    .search-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 20px 0;
      padding: 15px;
      background-color: var(--accent-color);
      border-radius: 5px;
    }
    
    .search-filter-item {
      flex: 1;
      min-width: 200px;
    }
    
    .search-filter-item label {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }
    
    .search-filter-actions {
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }
    
    /* Text Analysis Tools */
    .concordance-container {
      margin: 20px 0;
    }
    
    .concordance-form {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .concordance-form input {
      flex: 1;
      margin-bottom: 0;
    }
    
    .concordance-results {
      max-height: 400px;
      overflow-y: auto;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 15px;
      background-color: var(--card-background);
    }
    
    .concordance-item {
      padding: 10px;
      border-bottom: 1px solid var(--border-color);
    }
    
    .concordance-item:last-child {
      border-bottom: none;
    }
    
    .keyword-highlight {
      background-color: yellow;
      color: black;
      padding: 0 2px;
    }
    
    [data-theme="dark"] .keyword-highlight {
      background-color: #f39c12;
    }
    
    /* Confidence Metrics */
    .confidence-meter {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    
    .confidence-bar {
      flex: 1;
      height: 8px;
      background-color: var(--border-color);
      border-radius: 4px;
      overflow: hidden;
      margin-right: 10px;
    }
    
    .confidence-level {
      height: 100%;
      transition: width 0.3s;
    }
    
    .confidence-high {
      background-color: var(--success-color);
    }
    
    .confidence-medium {
      background-color: var(--warning-color);
    }
    
    .confidence-low {
      background-color: var(--error-color);
    }
    
    .confidence-score {
      min-width: 40px;
      text-align: right;
      font-size: 0.8rem;
    }
    
    /* Validation Interface */
    .validation-interface {
      margin: 20px 0;
      padding: 20px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--card-background);
    }
    
    .validation-field {
      margin-bottom: 15px;
    }
    
    .validation-field-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      margin-bottom: 5px;
    }
    
    .validation-confidence {
      font-size: 0.8rem;
      padding: 2px 8px;
      border-radius: 10px;
    }
    
    /* Citation Generator */
    .citation-generator {
      margin: 20px 0;
    }
    
    .citation-style-selector {
      margin-bottom: 15px;
    }
    
    .citation-output {
      padding: 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      background-color: var(--accent-color);
      font-family: 'Times New Roman', Times, serif;
      margin-bottom: 15px;
    }
    
    /* Keyboard Shortcuts Modal */
    .shortcuts-grid {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 10px 20px;
      margin: 20px 0;
    }
    
    .shortcut-key {
      display: inline-block;
      padding: 5px 10px;
      background-color: var(--accent-color);
      border-radius: 4px;
      font-family: monospace;
      font-weight: bold;
      text-align: center;
    }
    
    .shortcut-description {
      display: flex;
      align-items: center;
    }
    
    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }
    
    .toast {
      background-color: var(--card-background);
      color: var(--text-color);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      animation: slideIn 0.3s, fadeOut 0.5s 3s forwards;
      max-width: 300px;
    }
    
    .toast.success {
      border-left: 4px solid var(--success-color);
    }
    
    .toast.error {
      border-left: 4px solid var(--error-color);
    }
    
    .toast.info {
      border-left: 4px solid var(--secondary-color);
    }
    
    .toast.warning {
      border-left: 4px solid var(--warning-color);
    }
    
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes fadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
        transform: translateY(-30px);
      }
    }
    
    /* Cloud Tag Visualization */
    .cloud-tag-container {
      width: 100%;
      height: 400px;
      position: relative;
      margin: 20px 0;
    }
    
    .cloud-tag {
      position: absolute;
      white-space: nowrap;
      cursor: pointer;
      transition: transform 0.3s, color 0.3s;
    }
    
    .cloud-tag:hover {
      transform: scale(1.1);
      color: var(--secondary-color);
    }
    
    /* Report Generator */
    .report-template-selector {
      margin: 20px 0;
    }
    
    .report-output {
      margin: 20px 0;
      padding: 20px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background-color: var(--card-background);
      min-height: 200px;
    }
    
    /* Loader Styles */
    .loader-container {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 30px;
    }
    
    .loader {
      border: 5px solid rgba(0,0,0,0.1);
      border-top: 5px solid var(--secondary-color);
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  
    /*  Styles */
    .command-palette {
      position: fixed;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-background);
      color: var(--text-color);
      border-radius: var(--border-radius-lg);
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      width: 50%;
      max-width: 400px;
      display: none;
      z-index: 2000;
    }
    .command-palette input {
      width: 100%;
      padding: var(--spacing-md);
      border: none;
      border-bottom: 1px solid var(--border-color);
      border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
      outline: none;
      font-size: 1rem;
    }
    .command-palette ul {
      list-style: none;
      max-height: 200px;
      overflow-y: auto;
      margin: 0;
      padding: 0;
    }
    .command-palette li {
      padding: var(--spacing-sm) var(--spacing-md);
      cursor: pointer;
    }
    .command-palette li:hover, .command-palette li.active {
      background: var(--accent-color);
    }
    /* Drag-and-Drop Overlay */
    .drag-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      color: white;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      z-index: 1500;
    }
    
    .help-modal .modal-header, .help-modal .modal-body {
      padding: var(--spacing-md);
    }
    .help-modal .modal-header {
      border-bottom: 1px solid var(--border-color);
      font-weight: bold;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .help-modal .close-help {
      background: transparent;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      color: var(--light-text);
    }

    /* Sidebar Navigation */
    .sidebar {
      width: 240px;
      background-color: var(--secondary-color);
      color: white;
      height: 100vh;
      position: fixed;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      padding: var(--spacing-lg) 0;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      z-index: 100;
    }
    .sidebar nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .sidebar nav li {
      margin-bottom: var(--spacing-md);
    }
    .sidebar nav a {
      color: white;
      text-decoration: none;
      display: flex;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--border-radius-lg);
      font-weight: 600;
    }
    .sidebar nav a:hover,
    .sidebar nav a.active {
      background: var(--primary-color);
    }
    .sidebar .nav-icon {
      margin-right: 8px;
      font-size: 1.2rem;
    }
    /* Main content adjustment */
    .main-content {
      margin-left: 240px;
      padding: var(--spacing-lg);
    }
  
/* === Additional Background‚ÄëCentric Themes === */

/* Forest Theme Variables */
[data-theme="forest"] {
  --primary-color: #1b5e20;
  --secondary-color: #4caf50;
  --accent-color: #2e7d32;
  --text-color: #e8f5e9;
  --light-text: #c8e6c9;
  --border-color: #255d38;
  --background-color: #0d2615;
  --card-background: #17371f;
  --header-background: #1b5e20;
  --header-text: #e8f5e9;
  --footer-background: #1b5e20;
  --footer-text: #e8f5e9;
}

/* Ocean Theme Variables */
[data-theme="ocean"] {
  --primary-color: #003c8f;
  --secondary-color: #0288d1;
  --accent-color: #b3e5fc;
  --text-color: #e1f5fe;
  --light-text: #b3e5fc;
  --border-color: #01579b;
  --background-color: #001f3f;
  --card-background: #002f56;
  --header-background: #003c8f;
  --header-text: #e1f5fe;
  --footer-background: #003c8f;
  --footer-text: #e1f5fe;
}

/* Desert Theme Variables */
[data-theme="desert"] {
  --primary-color: #8d6e63;
  --secondary-color: #d7ccc8;
  --accent-color: #bcaaa4;
  --text-color: #3e2723;
  --light-text: #5d4037;
  --border-color: #a1887f;
  --background-color: #fff8e1;
  --card-background: #fbe9e7;
  --header-background: #8d6e63;
  --header-text: #fffde7;
  --footer-background: #8d6e63;
  --footer-text: #fffde7;
}

/* Sepia Theme Variables */
[data-theme="sepia"] {
  --primary-color: #704214;
  --secondary-color: #a05a2c;
  --accent-color: #f4ecd8;
  --text-color: #33220d;
  --light-text: #66523c;
  --border-color: #a38b71;
  --background-color: #f4ecd8;
  --card-background: #fdf7ec;
  --header-background: #704214;
  --header-text: #fdf7ec;
  --footer-background: #704214;
  --footer-text: #fdf7ec;
}

/* === Additional Eye‚ÄëComfort & Visualization‚ÄëOptimized Themes === */

/* Solarized Light Theme */
[data-theme="solarized-light"] {
  --primary-color: #268bd2;
  --secondary-color: #2aa198;
  --accent-color: #eee8d5;
  --text-color: #073642;
  --light-text: #586e75;
  --border-color: #93a1a1;
  --background-color: #fdf6e3;
  --card-background: #fefdfb;
  --header-background: #eee8d5;
  --header-text: #073642;
  --footer-background: #eee8d5;
  --footer-text: #073642;
  --chart-colors: #268bd2, #2aa198, #cb4b16, #b58900, #859900, #d33682, #6c71c4, #dc322f;
}

/* Solarized Dark Theme */
[data-theme="solarized-dark"] {
  --primary-color: #268bd2;
  --secondary-color: #2aa198;
  --accent-color: #002b36;
  --text-color: #93a1a1;
  --light-text: #657b83;
  --border-color: #073642;
  --background-color: #002b36;
  --card-background: #073642;
  --header-background: #002b36;
  --header-text: #93a1a1;
  --footer-background: #002b36;
  --footer-text: #93a1a1;
  --chart-colors: #268bd2, #2aa198, #cb4b16, #b58900, #859900, #d33682, #6c71c4, #dc322f;
}

/* Pastel Theme */
[data-theme="pastel"] {
  --primary-color: #82b1ff;
  --secondary-color: #ffcc80;
  --accent-color: #e1bee7;
  --text-color: #37474f;
  --light-text: #607d8b;
  --border-color: #b0bec5;
  --background-color: #fafafa;
  --card-background: #ffffff;
  --header-background: #82b1ff;
  --header-text: #ffffff;
  --footer-background: #82b1ff;
  --footer-text: #ffffff;
  --chart-colors: #82b1ff, #ffcc80, #b39ddb, #80deea, #ffab91, #c5e1a5, #ff9e80, #bcaaa4;
}

/* High Contrast Theme */
[data-theme="high-contrast"] {
  --primary-color: #ffffff;
  --secondary-color: #ffea00;
  --accent-color: #424242;
  --text-color: #ffffff;
  --light-text: #bdbdbd;
  --border-color: #757575;
  --background-color: #000000;
  --card-background: #212121;
  --header-background: #000000;
  --header-text: #ffea00;
  --footer-background: #000000;
  --footer-text: #ffea00;
  --chart-colors: #ffea00, #ff5722, #03a9f4, #cddc39, #e91e63, #9c27b0, #8bc34a, #f44336;
}
</style>
</head>
<body>
  <div class="drag-overlay" id="dragOverlay">Drop file to upload</div>
  <div class="command-palette" id="cmdPalette">
    <input type="text" id="cmdInput" placeholder="Type a command...">
    <ul id="cmdList">
      <li data-cmd="upload">Upload File</li>
      <li data-cmd="start">Start Processing</li>
      <li data-cmd="dashboard">Show Dashboard</li>
      <li data-cmd="timeline">Show Timeline</li>
      <li data-cmd="export">Open Export</li>
    </ul>
  </div>
  
  <div class="app-container">
    <aside class="sidebar" role="navigation" aria-label="Main navigation">
      <nav>
        <ul>
          <li><a href="#uploadSection" class="nav-link"><span class="nav-icon">üì§</span>Upload</a></li>
          <li><a href="#processSection" class="nav-link"><span class="nav-icon">‚ñ∂Ô∏è</span>Process</a></li>
          <li><a href="#analysisSection" class="nav-link"><span class="nav-icon">üìä</span>Analysis</a></li>
        </ul>
      </nav>
    </aside>

    <main class="main-content">
      <div class="header">
        <div class="theme-switch-wrapper">
          <span class="theme-label">Dark Mode</span>
          <label class="theme-switch">
            <input type="checkbox" id="themeSwitch">
            <span class="slider"></span>
          </label>
<select id="backgroundThemeSelect" aria-label="Theme selector" style="margin-left: 12px; padding:4px 8px; border-radius:4px;">
  <option value="light">Light</option>
  <option value="dark">Dark</option>
  <option value="forest">Forest</option>
  <option value="ocean">Ocean</option>
  <option value="desert">Desert</option>
  <option value="sepia">Sepia</option>

<option value="solarized-light">Solarized Light</option>
<option value="solarized-dark">Solarized Dark</option>
<option value="pastel">Pastel</option>
<option value="high-contrast">High Contrast</option>
</select>

        </div>
        <button id="shortcutsBtn" class="keyboard-shortcuts-btn">Keyboard Shortcuts</button>
        
        <div class="container">
          <h1 style="font-size: 3.2rem; margin-bottom: 0.3rem;">TransCorpora</h1>
          <p class="subtitle" style="font-size: 1.5rem; margin-top: 0.5rem;">Corpus Creation and Analysis for Archival Research</p>
        </div>
      </div>
      
      <div class="container">
        <div class="card">
          <div class="info-box">
            <h3>About TransCorpora</h3>
            <p>With TransCorpora, researchers can turn diverse archival datasets‚Äîranging from digitized book reviews to translation registry records‚Äîinto rich, analyzable corpora. Simply upload your files (Excel, PDF, DOCX, images) and let the tool extract translation-related metadata (translator names, original and translated titles, publication years, languages). Advanced visualization modules (dashboards, timelines, networks), text-analysis tools, and export options (Excel, CSV, citation formats) make it easy to uncover patterns, map translator networks, and generate publication-ready outputs in just a few clicks.</p>
            
          </div>
          
          <div class="settings-toggle">Advanced Configuration</div>
          <div class="settings-content">
            <div class="settings-grid">
              <div class="api-section">
                <h3>API Configuration</h3>
                <label for="apiKeyInput">OpenAI API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="Insert your OpenAI API Key here">
                <div id="apiKeyStatus" style="font-size: 14px; color: var(--success-color); margin-bottom: 15px;">API key loaded</div>
                <button id="saveApiKeyBtn">Save Key</button>
              </div>
              
              <div>
                <h3>Processing Parameters</h3>
                <label for="modelSelect">AI Model:</label>
                
                <select id="modelSelect">
                  <option value="gpt-4" data-description="GPT-4 (8K context window) ‚Äî most capable model.">GPT-4 (8K context)</option>
                  <option value="gpt-4-0613" data-description="GPT-4 (0613) ‚Äî security-focused GPT-4 variant.">GPT-4 (0613)</option>
                  <option value="gpt-4-32k" data-description="GPT-4-32K ‚Äî extended context (32K tokens).">GPT-4-32K</option>
                  <option value="gpt-4-32k-0613" data-description="GPT-4-32K (0613) ‚Äî 32K context, secure variant.">GPT-4-32K (0613)</option>
                  <option value="gpt-4o" data-description="GPT-4o ‚Äî experimental multimodal model.">GPT-4o (Multimodal experimental)</option>
                  <option value="gpt-4o-mini" data-description="GPT-4o-mini ‚Äî smaller multimodal model.">GPT-4o-mini</option>
                  <option value="gpt-3.5-turbo" data-description="GPT-3.5 Turbo ‚Äî fast, cost-effective model.">GPT-3.5 Turbo (4K)</option>
                  <option value="gpt-3.5-turbo-16k" data-description="GPT-3.5 Turbo (16K) ‚Äî extended context.">GPT-3.5 Turbo (16K)</option>
                  <option value="gpt-3.5-turbo-0613" data-description="GPT-3.5 Turbo (0613) ‚Äî secure variant.">GPT-3.5 Turbo (0613)</option>
                  <option value="gpt-3.5-turbo-16k-0613" data-description="GPT-3.5 Turbo 16K (0613).">GPT-3.5 Turbo (16K-0613)</option>
                </select>
                <p id="modelDesc" style="margin-top:8px;color:var(--text-color);font-style:italic;"></p>

                
                <label for="batchSizeInput">Batch Size:</label>
                <input type="number" id="batchSizeInput" min="1" max="5" value="1">
                <p class="help-text">Number of reviews to process in parallel (1-5). Smaller values are more reliable.</p>
                
                <label for="temperatureInput">Temperature:</label>
                <div style="display: flex; align-items: center;">
                  <input type="range" id="temperatureInput" min="0" max="10" value="1" style="flex: 1; margin-right: 10px;">
                  <span id="temperatureValue">0.1</span>
                </div>
                <p class="help-text">Controls randomness. Lower values produce more consistent results.</p>
                
                <div style="margin-top: 15px; padding: 10px; background-color: var(--accent-color); border-radius: 5px; border-left: 4px solid var(--secondary-color);">
                  <label for="assumeTranslatedCheckbox" style="display: flex; align-items: center; margin-bottom: 0;">
                    <input type="checkbox" id="assumeTranslatedCheckbox" style="width: auto; margin-right: 10px; margin-bottom: 0;" checked>
                    <span>Assume all reviews are about translations</span>
                  </label>
                  <p class="help-text" style="margin-top: 5px;">Enable this to process all reviews as translated book reviews, bypassing the AI detection.</p>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background-color: var(--accent-color); border-radius: 5px; border-left: 4px solid var(--secondary-color);">
                  <label for="assumeFullAIProcessing" style="display: flex; align-items: center; margin-bottom: 0;">
                    <input type="checkbox" id="assumeFullAIProcessing" style="width: auto; margin-right: 10px; margin-bottom: 0;" checked>
                    <span>Use AI to extract all metadata</span>
                  </label>
                  <p class="help-text" style="margin-top: 5px;">Enable for full AI analysis of content. Disable for minimal processing.</p>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background-color: var(--accent-color); border-radius: 5px; border-left: 4px solid var(--secondary-color);">
                  <label for="confidenceScoringCheckbox" style="display: flex; align-items: center; margin-bottom: 0;">
                    <input type="checkbox" id="confidenceScoringCheckbox" style="width: auto; margin-right: 10px; margin-bottom: 0;" checked>
                    <span>Enable Confidence Scoring</span>
                  </label>
                  <p class="help-text" style="margin-top: 5px;">Add confidence metrics for AI-extracted fields.</p>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background-color: var(--accent-color); border-radius: 5px; border-left: 4px solid var(--secondary-color);">
                  <label for="reanalysisCheckbox" style="display: flex; align-items: center; margin-bottom: 0;">
                    <input type="checkbox" id="reanalysisCheckbox" style="width: auto; margin-right: 10px; margin-bottom: 0;" checked>
                    <span>Enable Re-analysis with LLM API</span>
                  </label>
                  <p class="help-text" style="margin-top: 5px;">Use LLM API to re-analyze data when generating visualizations.</p>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background-color: var(--accent-color); border-radius: 5px; border-left: 4px solid var(--secondary-color);">
                  <label for="debugModeCheckbox" style="display: flex; align-items: center; margin-bottom: 0;">
                    <input type="checkbox" id="debugModeCheckbox" style="width: auto; margin-right: 10px; margin-bottom: 0;" checked>
                    <span>Debug Mode</span>
                  </label>
                  <p class="help-text" style="margin-top: 5px;">Enable to see detailed processing information.</p>
                </div>
              </div>
            </div>
          </div>
          
          
<!-- Updated Upload Section -->
<section id="uploadSection" class="upload-section" 
         style="
           border: 2px dashed var(--secondary-color); 
           padding: 24px; 
           text-align: center; 
           background-color: var(--accent-color); 
           border-radius: 10px; 
           position: relative;
           transition: background-color 0.3s ease;
         "
         ondragover="event.preventDefault(); this.style.backgroundColor = 'rgba(41,128,185,0.1)';" 
         ondragleave="this.style.backgroundColor = 'var(--accent-color)';" 
         ondrop="event.preventDefault(); handleFiles(event.dataTransfer.files); this.style.backgroundColor = 'var(--accent-color)';"
>
<div style="font-size: 2.5rem; color: var(--secondary-color); margin-bottom: 12px;">üì§</div>
<h2 style="color: var(--primary-color); margin-bottom: 8px;">Drag &amp; Drop or Click to Upload</h2>
<input type="file" id="fileInput" multiple accept=".xls,.xlsx,.pdf,.docx,.doc,.jpg,.jpeg,.png,.gif" ...>
<input type="file" id="fileInput" 
       accept=".xls,.xlsx,.pdf,.docx,.doc,.jpg,.jpeg,.png,.gif" 
       multiple
       style="
         opacity:0; 
         position:absolute; 
         width:100%; 
         height:100%; 
         top:0; left:0; 
         cursor:pointer;
       " 
       onchange="handleFiles(this.files)"
>
  <button id="uploadBtn" style="
           background-color: var(--secondary-color);
           color: white;
           border: none;
           padding: 10px 20px;
           border-radius: 5px;
           font-size: 1rem;
           font-weight: 600;
           cursor: pointer;
           margin-top: 8px;
         ">
    Choose a File
  </button>
  <div id="fileName" style="
           margin-top: 8px; 
           font-style: italic; 
           color: var(--text-color);
         ">
    No file chosen
  </div>
  <p class="help-text" style="margin-top:12px;">
    Supports Excel, PDF, Word documents, and images for translation archival research.
  </p>
</section>

<script>
  // Display selected file name
  // Display selected file name
function handleFiles(files) {
  const fileNameDisplay = document.getElementById('fileName');
  if (files.length === 0) {
    fileNameDisplay.textContent = 'No files chosen';
    // Explicitly disable the button when no files are selected
    document.getElementById('startProcessingBtn').disabled = true;
  } else if (files.length === 1) {
    fileNameDisplay.textContent = files[0].name;
    // Explicitly enable the button with a single file
    document.getElementById('startProcessingBtn').disabled = false;
  } else {
    fileNameDisplay.textContent = `${files.length} files selected`;
    // Show file list in a tooltip or small preview
    let fileListHTML = '<ul style="text-align: left; margin-top: 5px; font-size: 0.9em;">';
    for (let i = 0; i < Math.min(files.length, 5); i++) {
      fileListHTML += `<li>${files[i].name}</li>`;
    }
    if (files.length > 5) {
      fileListHTML += `<li>...and ${files.length - 5} more</li>`;
    }
    fileListHTML += '</ul>';
    
    // Add this list below the file name display
    const fileListElement = document.createElement('div');
    fileListElement.id = 'fileListPreview';
    fileListElement.className = 'file-list-preview';
    fileListElement.innerHTML = fileListHTML;
    
    // Replace existing preview if any
    const existingPreview = document.getElementById('fileListPreview');
    if (existingPreview) {
      existingPreview.parentNode.removeChild(existingPreview);
    }
    
    fileNameDisplay.insertAdjacentElement('afterend', fileListElement);
    
    // Explicitly enable the button with multiple files
    document.getElementById('startProcessingBtn').disabled = false;
  }
  
  // Add additional debugging
  console.log(`Files selected: ${files.length}`);
  console.log(`Start button disabled: ${document.getElementById('startProcessingBtn').disabled}`);
  
  // Make sure to also trigger file upload processing
  if (files.length > 0) {
    handleFileUpload({target: {files: files}});
  }
}
  // Make the Choose button trigger the hidden file input
  document.getElementById('uploadBtn').addEventListener('click', () => {
    document.getElementById('fileInput').click();
  });
</script>

<div class="section-title" id="processSection">
            <span>2</span>
            <h2>Process Records</h2>
          </div>
          
          <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
          </div>
          <div class="progress-label" id="progressLabel">0 / 0 reviews processed</div>
          <div class="status" id="status" aria-live="polite">Waiting for file.....</div>
          
          <div>
            <button id="startProcessingBtn" disabled>Start Processing</button>
            <button id="pauseProcessingBtn" disabled>Pause</button>
            <button id="resumeProcessingBtn" disabled>Resume</button>
            <button id="downloadCurrentBtn" disabled>Download Results (Excel)</button>
            <button id="downloadCSVBtn" disabled>Download as CSV</button>
          </div>
          
          <div class="log-console" id="logConsole">
            > Ready to process historical New York Times book reviews
          </div>
          
          <div class="section-title" id="analysisSection">
            <span>3</span>
            <h2>Analysis & Visualization</h2>
          </div>
          
          <div class="tab-container" id="analysisTabContainer">
            <div class="tab-nav">
              <button class="tab-button active" data-tab="results">Results Table</button>
              <button class="tab-button" data-tab="dashboard">Statistics Dashboard</button>
              <button class="tab-button" data-tab="timeline">Historical Timeline</button>
              <button class="tab-button" data-tab="network">Translation Networks</button>
              <button class="tab-button" data-tab="textAnalysis">Text Analysis</button>
              <button class="tab-button" data-tab="validation">Validation Interface</button>
              <button class="tab-button" data-tab="export">Advanced Export</button>
            </div>
            
            <!-- Results Tab -->
            <div class="tab-content active" id="resultsTab">
              <div class="search-filter-bar">
                <div class="search-filter-item">
                  <label for="searchInput">Search:</label>
                  <input type="text" id="searchInput" placeholder="Search in results...">
                </div>
                <div class="search-filter-item">
                  <label for="filterField">Filter by:</label>
                  <select id="filterField">
                    <option value="all" data-description="">All Fields</option>
                    <option value="Review_Type" data-description="">Review Type</option>
                    <option value="Translator_Name" data-description="">Translator</option>
                    <option value="Source_Language" data-description="">Source Language</option>
                    <option value="Author_Name" data-description="">Author</option>
                    <option value="Genre_Category" data-description="">Genre</option>
                  </select>
                </div>
                <div class="search-filter-item">
                  <label for="sortField">Sort by:</label>
                  <select id="sortField">
                    <option value="Review_Date" data-description="">Review Date</option>
                    <option value="Review_Title" data-description="">Review Title</option>
                    <option value="Translator_Name" data-description="">Translator Name</option>
                    <option value="Author_Name" data-description="">Author Name</option>
                  </select>
                </div>
                <div class="search-filter-actions">
                  <button id="applyFiltersBtn">Apply Filters</button>
                  <button id="resetFiltersBtn">Reset</button>
                </div>
              </div>
              
              <div id="results">
                <p>No file processed yet. Upload a file and click the Start Processing button.</p>
              </div>
            </div>
            
            <!-- Statistics Dashboard Tab -->
            <div class="tab-content" id="dashboardTab">
              <h3>Statistical Overview</h3>
              <div class="stats-container" id="statsContainer">
                <!-- Stats cards will be inserted here -->
              </div>
              
              <div class="chart-container">
                <canvas id="sourceLangChart"></canvas>
              </div>
              
              <div style="display: flex; gap: 20px; margin-top: 20px;">
                <div style="flex: 1;">
                  <div class="small-chart-container">
                    <canvas id="reviewTypeChart"></canvas>
                  </div>
                </div>
                <div style="flex: 1;">
                  <div class="small-chart-container">
                    <canvas id="translatorVisibilityChart"></canvas>
                  </div>
                </div>
              </div>
              
              <div class="chart-container">
                <canvas id="yearlyTrendsChart"></canvas>
              </div>
            </div>
            
            <!-- Historical Timeline Tab -->
            <div class="tab-content" id="timelineTab">
              <h3>Historical Translation Timeline</h3>
              
              <div class="search-filter-bar">
                <div class="search-filter-item">
                  <label for="timelineStartYear">Start Year:</label>
                  <input type="number" id="timelineStartYear" min="1851" max="2025" value="1851">
                </div>
                <div class="search-filter-item">
                  <label for="timelineEndYear">End Year:</label>
                  <input type="number" id="timelineEndYear" min="1851" max="2025" value="2025">
                </div>
                <div class="search-filter-item">
                  <label for="timelineGroupBy">Group by:</label>
                  <select id="timelineGroupBy">
                    <option value="year" data-description="">Year</option>
                    <option value="decade" data-description="">Decade</option>
                    <option value="source_language" data-description="">Source Language</option>
                    <option value="review_type" data-description="">Review Type</option>
                  </select>
                </div>
                <div class="search-filter-actions">
                  <button id="applyTimelineBtn">Apply</button>
                </div>
              </div>
              
              <div class="timeline-container">
                <div id="timelineViz" class="timeline"></div>
              </div>
              
              <div class="chart-container">
                <canvas id="timelineChart"></canvas>
              </div>
            </div>
            
            <!-- Translation Networks Tab -->
            <div class="tab-content" id="networkTab">
              <h3>Translation Networks</h3>
              
              <div class="search-filter-bar">
                <div class="search-filter-item">
                  <label for="networkType">Network Type:</label>
                  <select id="networkType">
                    <option value="translator_author" data-description="">Translator-Author Connections</option>
                    <option value="translator_publisher" data-description="">Translator-Publisher Connections</option>
                    <option value="author_language" data-description="">Author-Language Connections</option>
                    <option value="translator_language" data-description="">Translator-Language Connections</option>
                  </select>
                </div>
                <div class="search-filter-item">
                  <label for="networkMinConnections">Minimum Connections:</label>
                  <input type="number" id="networkMinConnections" min="1" max="10" value="1">
                </div>
                <div class="search-filter-actions">
                  <button id="generateNetworkBtn">Generate Network</button>
                </div>
              </div>
              
              <div class="network-container" id="networkViz"></div>
              
              <div class="info-box">
                <h4>Network Interpretation</h4>
                <p>This visualization shows relationships between key entities in the translation ecosystem. Larger nodes represent more influential figures or elements. Thicker lines indicate stronger connections.</p>
                <p>You can drag nodes to rearrange the network, hover for details, and zoom with the mouse wheel.</p>
              </div>
            </div>
            
            <!-- Text Analysis Tab -->
            <div class="tab-content" id="textAnalysisTab">
              <h3>Text Analysis Tools</h3>
              
              <h4>Concordance Analysis</h4>
              <div class="concordance-container">
                <div class="concordance-form">
                  <input type="text" id="concordanceInput" placeholder="Enter term to search (e.g., 'faithful', 'translator')">
                  <button id="concordanceSearchBtn">Search</button>
                </div>
                <div class="concordance-results" id="concordanceResults">
                  <p>Enter a term above to search through all review texts.</p>
                </div>
              </div>
              
              <h4>Keyword Frequency Analysis</h4>
              <div class="search-filter-bar">
                <div class="search-filter-item">
                  <label for="keywordField">Analyze field:</label>
                  <select id="keywordField">
                    <option value="Review_Article_Text" data-description="">Review Text</option>
                    <option value="Translation_Quality_Comments" data-description="">Translation Quality Comments</option>
                    <option value="Quoted_Passages_About_Translation" data-description="">Quoted Passages About Translation</option>
                    <option value="Critical_Vocabulary_About_Translation" data-description="">Critical Vocabulary</option>
                  </select>
                </div>
                <div class="search-filter-item">
                  <label for="keywordMinFreq">Minimum frequency:</label>
                  <input type="number" id="keywordMinFreq" min="1" max="100" value="3">
                </div>
                <div class="search-filter-actions">
                  <button id="generateKeywordsBtn">Generate Keywords</button>
                </div>
              </div>
              
              <div class="cloud-tag-container" id="keywordCloud"></div>
              
              <h4>Translation Discourse Patterns</h4>
              <div class="small-chart-container">
                <canvas id="discoursePatternChart"></canvas>
              </div>
            </div>
            
            <!-- Validation Interface Tab -->
            <div class="tab-content" id="validationTab">
              <h3>Human Validation Interface</h3>
              <p class="help-text">Review and correct AI-extracted metadata fields. Records with corrections will be marked as human-validated.</p>
              
              <div class="search-filter-bar">
                <div class="search-filter-item">
                  <label for="validationRecordSelect">Select Record:</label>
                  <select id="validationRecordSelect">
                    <option value="">-- Select a record to validate --</option>
                  </select>
                </div>
                <div class="search-filter-item">
                  <label for="confidenceThreshold">Confidence Threshold:</label>
                  <select id="confidenceThreshold">
                    <option value="all" data-description="">Show All Fields</option>
                    <option value="low" selected>Low Confidence Only</option>
                    <option value="medium" data-description="">Medium or Lower</option>
                    <option value="high" data-description="">High or Lower</option>
                  </select>
                </div>
              </div>
              
              <div id="validationInterface" class="validation-interface">
                <p>Please select a record to validate.</p>
              </div>
              
              <div>
                <button id="saveValidationBtn" disabled>Save Validation</button>
                <button id="skipValidationBtn" disabled>Skip Record</button>
                <button id="bulkExportValidatedBtn" disabled>Export Validated Records</button>
              </div>
            </div>
            
            <!-- Advanced Export Tab -->
            <div class="tab-content" id="exportTab">
              <h3>Advanced Export Options</h3>
              
              <h4>Citation Generator</h4>
              <div class="citation-generator">
                <div class="citation-style-selector">
                  <label for="citationStyle">Citation Style:</label>
                  <select id="citationStyle">
                    <option value="mla" data-description="">MLA</option>
                    <option value="apa" data-description="">APA</option>
                    <option value="chicago" data-description="">Chicago</option>
                    <option value="harvard" data-description="">Harvard</option>
                  </select>
                </div>
                
                <div class="search-filter-item">
                  <label for="citationRecord">Select Record:</label>
                  <select id="citationRecord">
                    <option value="">-- Select a record to cite --</option>
                  </select>
                </div>
                
                <button id="generateCitationBtn">Generate Citation</button>
                
                <div class="citation-output" id="citationOutput">
                  Citation will appear here.
                </div>
                
                <button id="copyCitationBtn">Copy Citation</button>
              </div>
              
              <h4>Custom Field Selection</h4>
              <div>
                <p class="help-text">Select fields to include in your export</p>
                <div id="customFieldSelection" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 10px; margin: 15px 0;">
                  <!-- Checkboxes will be inserted here -->
                </div>
                
                <button id="customExportBtn">Export Selected Fields</button>
              </div>
              
              <h4>Report Generator</h4>
              <div class="report-template-selector">
                <label for="reportTemplate">Report Template:</label>
                <select id="reportTemplate">
                  <option value="overview" data-description="">Corpus Overview</option>
                  <option value="translators" data-description="">Translators Summary</option>
                  <option value="languages" data-description="">Source Languages Analysis</option>
                  <option value="timeline" data-description="">Historical Timeline Report</option>
                  <option value="publishers" data-description="">Publishers Analysis</option>
                  <option value="custom" data-description="">Custom Report</option>
                </select>
                
                <div id="customReportOptions" style="display: none; margin-top: 15px;">
                  <label for="customReportTitle">Report Title:</label>
                  <input type="text" id="customReportTitle" placeholder="Enter custom report title">
                  
                  <label for="customReportSections">Include Sections:</label>
                  <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="overview" checked> Overview
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="translators" checked> Translators
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="languages" checked> Languages
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="timeline" checked> Timeline
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="publishers"> Publishers
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="reception"> Reception Analysis
                    </label>
                    <label style="display: inline-flex; align-items: center;">
                      <input type="checkbox" value="charts" checked> Charts & Graphs
                    </label>
                  </div>
                </div>
                
                <button id="generateReportBtn">Generate Report</button>
              </div>
              
              <div class="report-output" id="reportOutput">
                <!-- Report content will be inserted here -->
              </div>
              
              <button id="downloadReportBtn">Download Report</button>
            </div>
            </div>

      
      <!-- Modals -->
      <div id="fieldModal" class="modal">
        <div class="modal-content">
          <span class="close">&times;</span>
          <h3 id="modalTitle">Review Details</h3>
          <div id="modalContent"></div>
        </div>
      </div>
      
      <div id="shortcutsModal" class="modal">
        <div class="modal-content">
          <span class="close">&times;</span>
          <h3>Keyboard Shortcuts</h3>
          <div class="shortcuts-grid">
            <div class="shortcut-key">Ctrl+U</div><div class="shortcut-description">Upload file</div>
            <div class="shortcut-key">Ctrl+P</div><div class="shortcut-description">Start processing</div>
            <div class="shortcut-key">Ctrl+S</div><div class="shortcut-description">Save API key</div>
          </div>
        </div>
      </div>
      
      <div class="toast-container" id="toastContainer">
        <!-- Toast notifications will appear here -->
      </div>
      
      <div class="footer">
        <div class="container">
          <p>TransCorpora ¬© 2025. All rights reserved.</p>
          <p>Developed by Hussein Abu-Rayyash</p>
          <p>Advanced Corpus Creation and Analysis Tool for Archival Research</p>
        </div>
      </div>
    </main>
  </div>
  
  <script>
    // Debounce utility
    function debounce(fn, delay) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // Global variables
    let apiKey = ""; // Insert your API key here
    let workbook = null;
    let processedData = [];
    let originalData = [];
    let filteredData = []; // For search and filtering
    let currentBatch = 0;
    let processingPaused = false;
    let totalReviews = 0;
    let processedReviews = 0;
    let processing = false;
    let processedIds = new Set(); // Track processed review IDs to prevent duplicates
    let validatedRecords = new Set(); // Track human-validated records
    let chartInstances = {}; // Store chart instances for updating
    let networkInstance = null; // Store network visualization instance
    let batchSizeAdjusted = false; // Track if batch size was auto-adjusted
    
    // Define the desired column order and exclude list for output
    const excludeColumns = [
      'StoreId', 'ArticleType', 'copyright', 'documentType', 'entryDate',
      'issn', 'language', 'languageOfSummary', 'pages', 'placeOfPublication',
      'pubdate', 'pubtitle', 'FindACopy', 'Database', 'Original_Publisher',
      'Review_Publication', 'IsTranslatedBookReview', 'LLM_Processing_Error'
    ];
    
    // Define the column order for better organization (Updated with new categories)
    const columnOrder = [
      // A: Review identification
      'Review_ID',
      'Review_Title',
      'Review_Date',
      'Review_Year',
      'Review_Type',
      'Review_URL',
      'Review_Article_Text',
      'Review_Abstract',
      'Review_Author',
      
      // B: Core translation information
      'Translated_Title',
      'Original_Title',
      'Author_Name',
      'Author_Nationality',
      'Subject_Of_Work',
      'Translator_Name',
      'Source_Language',
      'Target_Language',
      
      // C: Publication details
      'Translation_Publisher',
      'Translation_Status',
      'Edition_Information',
      'Translation_Publication_Year',
      'Original_Publication_Year',
      
      // D: Translation analysis
      'Translation_Approach',
      'Translation_Quality_Comments',
      'Cultural_Adaptation_Notes',
      'Reception_Of_Translation',
      'Comparison_To_Original',
      'Translator_Visibility',
      'Paratextual_Elements',
      
      // E: Translator and author context
      'Translator_Recognition',
      'Translator_Previous_Works',
      'Author_Recognition',
      'Author_Previous_Works',
      
      // F: Contextual information
      'Historical_Significance',
      'Retranslation_Context',
      'Historical_Period',
      'Literary_Movement',
      'Geographic_Focus',
      'Genre_Category',
      'Thematic_Elements',
      
      // G: Textual and Discursive Features (New section)
      'Quoted_Passages_About_Translation',
      'Reviewer_Tone_Toward_Translation',
      'Intertextual_References',
      'Critical_Vocabulary_About_Translation',
      'Translator_Framing_Strategy',
      'Sociopolitical_Commentary',
      'Presence_Of_Reviewer_Multilingualism',
      
      // Additional Meta Columns (New section)
      'Review_Word_Count',
      'Mentions_Translator_In_First_Paragraph',
      'Mentions_Translation_In_Title'
    ];
    
    // DOM elements initialization
    function initDOMElements() {
        // Core elements
        window.fileInput = document.getElementById('fileInput');
        window.saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
        window.apiKeyInput = document.getElementById('apiKeyInput');
        window.apiKeyStatus = document.getElementById('apiKeyStatus');
        window.progressBar = document.getElementById('progressBar');
        window.progressLabel = document.getElementById('progressLabel');
        window.statusElement = document.getElementById('status');
        window.resultsElement = document.getElementById('results');
        window.logConsole = document.getElementById('logConsole');
        window.modelSelect = document.getElementById('modelSelect');
        window.batchSizeInput = document.getElementById('batchSizeInput');
        window.temperatureInput = document.getElementById('temperatureInput');
        window.temperatureValue = document.getElementById('temperatureValue');
        window.startProcessingBtn = document.getElementById('startProcessingBtn');
        window.pauseProcessingBtn = document.getElementById('pauseProcessingBtn');
        window.resumeProcessingBtn = document.getElementById('resumeProcessingBtn');
        window.downloadCurrentBtn = document.getElementById('downloadCurrentBtn');
        window.downloadCSVBtn = document.getElementById('downloadCSVBtn');
        window.modal = document.getElementById('fieldModal');
        window.modalClose = document.querySelector('#fieldModal .close');
        window.modalTitle = document.getElementById('modalTitle');
        window.modalContent = document.getElementById('modalContent');
        window.settingsToggle = document.querySelector('.settings-toggle');
        window.settingsContent = document.querySelector('.settings-content');
        window.themeSwitch = document.getElementById('themeSwitch');
        window.shortcutsBtn = document.getElementById('shortcutsBtn');
        window.shortcutsModal = document.getElementById('shortcutsModal');
        window.shortcutsModalClose = document.querySelector('#shortcutsModal .close');
        window.confidenceScoringCheckbox = document.getElementById('confidenceScoringCheckbox');
        window.toastContainer = document.getElementById('toastContainer');
        window.searchInput = document.getElementById('searchInput');
        window.filterField = document.getElementById('filterField');
        window.sortField = document.getElementById('sortField');
        window.applyFiltersBtn = document.getElementById('applyFiltersBtn');
        window.resetFiltersBtn = document.getElementById('resetFiltersBtn');
        window.assumeTranslatedCheckbox = document.getElementById('assumeTranslatedCheckbox');
        window.assumeFullAIProcessing = document.getElementById('assumeFullAIProcessing');
        window.debugModeCheckbox = document.getElementById('debugModeCheckbox');
        
        // Tab navigation
        window.tabButtons = document.querySelectorAll('.tab-button');
        window.tabContents = document.querySelectorAll('.tab-content');
        
        // Visualization elements
        window.statsContainer = document.getElementById('statsContainer');
        window.sourceLangChart = document.getElementById('sourceLangChart');
        window.reviewTypeChart = document.getElementById('reviewTypeChart');
        window.translatorVisibilityChart = document.getElementById('translatorVisibilityChart');
        window.yearlyTrendsChart = document.getElementById('yearlyTrendsChart');
        window.timelineChart = document.getElementById('timelineChart');
        window.timelineViz = document.getElementById('timelineViz');
        window.networkViz = document.getElementById('networkViz');
        window.keywordCloud = document.getElementById('keywordCloud');
        window.discoursePatternChart = document.getElementById('discoursePatternChart');

        // Make sure all these elements exist before proceeding
        return (
            fileInput && saveApiKeyBtn && apiKeyInput && apiKeyStatus && 
            progressBar && progressLabel && statusElement && resultsElement && 
            logConsole && modelSelect && batchSizeInput && temperatureInput
        );
    }

    // Initialize Dark Mode from localStorage preference
    function initializeTheme() {
      const savedTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', savedTheme);
      if (savedTheme === 'dark') {
        themeSwitch.checked = true;
      }
    }
    
    // Toggle dark mode
    function toggleDarkMode() {
      if (themeSwitch.checked) {
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      } else {
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      }
      
      // Update charts if they exist
      updateAllCharts();
    }
    
    // Update all charts when theme changes
    function updateAllCharts() {
      // Only update if charts are initialized
      for (const chartId in chartInstances) {
        if (chartInstances[chartId]) {
          updateChartTheme(chartInstances[chartId]);
        }
      }
      
      // Regenerate network if it exists
      if (networkInstance && document.getElementById('networkTab').classList.contains('active')) {
        generateNetwork();
      }
    }
    
    // Update chart theme based on current mode
    function updateChartTheme(chart) {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      // Update text color
      chart.options.plugins.title.color = isDark ? '#ecf0f1' : '#333';
      chart.options.plugins.legend.labels.color = isDark ? '#ecf0f1' : '#333';
      
      // Update scales colors
      if (chart.options.scales.x) {
        chart.options.scales.x.ticks.color = isDark ? '#ecf0f1' : '#333';
        chart.options.scales.x.grid.color = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      }
      
      if (chart.options.scales.y) {
        chart.options.scales.y.ticks.color = isDark ? '#ecf0f1' : '#333';
        chart.options.scales.y.grid.color = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      }
      
      chart.update();
    }
    
    // Initialize event listeners
    function initEventListeners() {
      // Theme switch
      themeSwitch.addEventListener('change', toggleDarkMode);
      
      // Settings toggle
      settingsToggle.addEventListener('click', function() {
        settingsToggle.classList.toggle('active');
        settingsContent.classList.toggle('show');
      });
      
      // Close modals
      modalClose.addEventListener('click', function() {
        modal.style.display = 'none';
      });
      
      // Close modals when clicking outside
      window.addEventListener('click', function(event) {
        if (event.target === modal) {
          modal.style.display = 'none';
        }
        if (event.target === shortcutsModal) {
          shortcutsModal.style.display = 'none';
        }
      });
      
      // Shortcuts modal
      shortcutsBtn.addEventListener('click', function() {
        shortcutsModal.style.display = 'block';
      });
      
      shortcutsModalClose.addEventListener('click', function() {
        shortcutsModal.style.display = 'none';
      });
      
      // Tab navigation
      tabButtons.forEach(button => {
        button.addEventListener('click', function() {
          // Remove active class from all buttons and contents
          tabButtons.forEach(btn => btn.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and corresponding content
          this.classList.add('active');
          const tabId = this.getAttribute('data-tab') + 'Tab';
          document.getElementById(tabId).classList.add('active');
          
          // Special actions for certain tabs
          if (tabId === 'dashboardTab' && processedData.length > 0) {
            createDataDashboard();
          } else if (tabId === 'timelineTab' && processedData.length > 0) {
            createTimelineVisualization();
          } else if (tabId === 'networkTab' && processedData.length > 0) {
            generateNetwork();
          } else if (tabId === 'textAnalysisTab' && processedData.length > 0) {
            initializeTextAnalysis();
          } else if (tabId === 'validationTab' && processedData.length > 0) {
            initializeValidationInterface();
          } else if (tabId === 'exportTab' && processedData.length > 0) {
            initializeExportOptions();
          }
        });
      });
      
      // Temperature slider
      temperatureInput.addEventListener('input', function() {
        temperatureValue.textContent = (parseInt(this.value) / 10).toFixed(1);
      });
      
      // API Key handling
      saveApiKeyBtn.addEventListener('click', function() {
        const key = apiKeyInput.value.trim();
        if (key) {
          apiKey = key;
          apiKeyStatus.textContent = "API key saved";
          apiKeyStatus.style.color = "var(--success-color)";
          logToConsole("API key saved successfully");
          checkStartButtonState();
        } else {
          apiKeyStatus.textContent = "Please enter a valid API key";
          apiKeyStatus.style.color = "var(--error-color)";
        }
      });
      
      // File input handling
      fileInput.addEventListener('change', handleFileUpload);
      
      // Button event listeners
      startProcessingBtn.addEventListener('click', startProcessing);
      pauseProcessingBtn.addEventListener('click', pauseProcessing);
      resumeProcessingBtn.addEventListener('click', resumeProcessing);
      downloadCurrentBtn.addEventListener('click', downloadExcel);
      downloadCSVBtn.addEventListener('click', downloadCSV);
      
      // Filter and search listeners
      applyFiltersBtn.addEventListener('click', applyFilters);
      resetFiltersBtn.addEventListener('click', resetFilters);
      searchInput.addEventListener('keyup', function(e) {
        if (e.key === 'Enter') {
          applyFilters();
        }
      });
      
      // Analysis tab listeners
      document.getElementById('applyTimelineBtn')?.addEventListener('click', function() {
        // Check if we should use LLM API for re-analysis
        if (document.getElementById('reanalysisCheckbox')?.checked) {
          logToConsole("Using LLM API to re-analyze data for timeline visualization...");
          reanalyzeForTimeline();
        } else {
          createTimelineVisualization();
        }
      });
      
      document.getElementById('generateNetworkBtn')?.addEventListener('click', function() {
        // Check if we should use LLM API for re-analysis
        if (document.getElementById('reanalysisCheckbox')?.checked) {
          logToConsole("Using LLM API to re-analyze data for network visualization...");
          reanalyzeForNetwork();
        } else {
          generateNetwork();
        }
      });
      
      document.getElementById('generateKeywordsBtn')?.addEventListener('click', function() {
        // Check if we should use LLM API for re-analysis
        if (document.getElementById('reanalysisCheckbox')?.checked) {
          logToConsole("Using LLM API to re-analyze data for keyword cloud...");
          reanalyzeForKeywords();
        } else {
          generateKeywordCloud();
        }
      });
      
      document.getElementById('concordanceSearchBtn')?.addEventListener('click', performConcordanceSearch);
      
      // Validation tab listeners
      document.getElementById('validationRecordSelect')?.addEventListener('change', loadRecordForValidation);
      document.getElementById('saveValidationBtn')?.addEventListener('click', saveValidation);
      document.getElementById('skipValidationBtn')?.addEventListener('click', skipValidation);
      document.getElementById('bulkExportValidatedBtn')?.addEventListener('click', exportValidatedRecords);
      
      // Export tab listeners
      document.getElementById('reportTemplate')?.addEventListener('change', function() {
        document.getElementById('customReportOptions').style.display = 
          this.value === 'custom' ? 'block' : 'none';
      });
      
      document.getElementById('generateCitationBtn')?.addEventListener('click', generateCitation);
      document.getElementById('copyCitationBtn')?.addEventListener('click', copyCitation);
      document.getElementById('customExportBtn')?.addEventListener('click', exportCustomFields);
      document.getElementById('generateReportBtn')?.addEventListener('click', generateReport);
      document.getElementById('downloadReportBtn')?.addEventListener('click', downloadReport);

      // Model description update
      modelSelect.addEventListener('change', () => {
        const desc = modelSelect.selectedOptions[0].dataset.description || '';
        document.getElementById('modelDesc').textContent = desc;
      });
      // Initialize description
      document.getElementById('modelDesc').textContent = modelSelect.selectedOptions[0].dataset.description;

      // Keyboard shortcuts
      document.addEventListener('keydown', e => {
        if (e.ctrlKey && e.key === 'u') {
          e.preventDefault();
          fileInput.click();
        } else if (e.ctrlKey && e.key === 'p') {
          e.preventDefault();
          if (!startProcessingBtn.disabled) {
            startProcessingBtn.click();
          }
        } else if (e.ctrlKey && e.key === 's') {
          e.preventDefault();
          saveApiKeyBtn.click();
        } else if (e.ctrlKey && e.key === 'k') {
          e.preventDefault();
          document.getElementById('cmdPalette').style.display = 'block';
          document.getElementById('cmdInput').focus();
          highlightCmd();
        }
      });
    }

    // Handle file upload
    function handleFileUpload(e) {
      const files = e.target.files;
      if (!files || files.length === 0) {
        statusElement.textContent = 'No files selected';
        return;
      }
      
      statusElement.textContent = `Reading ${files.length} file(s)...`;
      progressBar.style.width = '10%';
      
      logToConsole(`Processing ${files.length} file(s)`);
      
      // Reset data
      originalData = [];
      processedData = [];
      processedIds.clear();
      
      // Create a queue of files to process
      window.fileQueue = Array.from(files);
      window.totalFileCount = files.length;
      window.currentFileIndex = 0;
      
      // Process the first file in queue
      processNextFileInQueue();
    }

    // New function to process files one by one
    function processNextFileInQueue() {
      if (!window.fileQueue || window.fileQueue.length === 0) {
        // All files processed
        statusElement.textContent = 'All files processed. Ready to start data extraction.';
        progressBar.style.width = '30%';
        return;
      }
      
      const file = window.fileQueue.shift();
      window.currentFileIndex++;
      
      statusElement.textContent = `Processing file ${window.currentFileIndex} of ${window.totalFileCount}: ${file.name}`;
      logToConsole(`Processing file: ${file.name} (${file.type})`);
      
      // Determine file type and process accordingly
      const fileType = file.type || '';
      const fileName = file.name.toLowerCase();
      
      const fileProgress = {
        start: 10 + ((window.currentFileIndex - 1) / window.totalFileCount) * 20,
        end: 10 + (window.currentFileIndex / window.totalFileCount) * 20
      };
      
      progressBar.style.width = `${fileProgress.start}%`;
      
      let processPromise;
      
      // Check if it's an Excel file
      if (fileType.includes('excel') || fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
        processPromise = processExcelFileAsync(file, fileProgress);
      }
      // Check if it's a PDF file
      else if (fileType.includes('pdf') || fileName.endsWith('.pdf')) {
        processPromise = processPdfFileAsync(file, fileProgress);
      }
      // Check if it's a Word document
      else if (fileType.includes('word') || fileName.endsWith('.docx') || fileName.endsWith('.doc')) {
        processPromise = processWordFileAsync(file, fileProgress);
      }
      // Check if it's an image
      else if (fileType.includes('image') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || 
              fileName.endsWith('.png') || fileName.endsWith('.gif')) {
        processPromise = processImageFileAsync(file, fileProgress);
      }
      // Unknown file type
      else {
        logToConsole(`Skipping unsupported file type: ${fileType} - ${fileName}`);
        showToast(`Skipped unsupported file: ${fileName}`, 'warning');
        // Continue with next file
        processNextFileInQueue();
        return;
      }
      
      // After current file is processed, move to the next
      processPromise.then(() => {
        // Short delay to prevent UI locking
        setTimeout(processNextFileInQueue, 100);
      }).catch(error => {
        logToConsole(`Error processing ${file.name}: ${error.message}`);
        showToast(`Error processing ${file.name}`, 'error');
        // Continue with next file despite error
        setTimeout(processNextFileInQueue, 100);
      });
    }
    
    // Process Excel file
    function processExcelFileAsync(file, fileProgress) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const data = new Uint8Array(e.target.result);
            
            // Update initial progress
            progressBar.style.width = `${fileProgress.start + 5}%`;
            statusElement.textContent = `Processing Excel file ${file.name}...`;
            
            const fileWorkbook = XLSX.read(data, { 
              type: 'array', 
              cellDates: true, 
              cellStyles: true
            });
            
            // Update progress to middle point
            const midProgress = (fileProgress.start + fileProgress.end) / 2;
            progressBar.style.width = `${midProgress}%`;
            
            // Log all sheet names for debugging
            logToConsole(`File ${file.name} contains ${fileWorkbook.SheetNames.length} sheets: ${fileWorkbook.SheetNames.join(', ')}`);
            
            // Extract reviews from the workbook (first sheet)
            const worksheet = fileWorkbook.Sheets[fileWorkbook.SheetNames[0]];
            
            // Log worksheet range and some cell values for debugging
            const range = XLSX.utils.decode_range(worksheet['!ref']);
            logToConsole(`Worksheet range: ${worksheet['!ref']}, Rows: ${range.e.r - range.s.r + 1}, Columns: ${range.e.c - range.s.c + 1}`);
            
            // Get headers to understand the data structure
            const headers = [];
            for (let C = range.s.c; C <= range.e.c; ++C) {
              const cell = worksheet[XLSX.utils.encode_cell({r: range.s.r, c: C})];
              if (cell && cell.v) headers.push(cell.v);
            }
            logToConsole(`Column headers: ${headers.join(', ')}`);
            
            // Parse the worksheet to JSON
            const fileData = XLSX.utils.sheet_to_json(worksheet);
            
            if (fileData.length === 0) {
              logToConsole(`WARNING: No data rows found in ${file.name}. Trying alternative parsing method...`);
              
              // Try parsing with different options
              const altData = XLSX.utils.sheet_to_json(worksheet, { 
                header: 1,  // Use 1-based indexing
                range: range // Use the full range
              });
              
              // If we got an array of arrays, convert to objects with column headers
              if (altData.length > 1 && Array.isArray(altData[0])) {
                const headerRow = altData[0];
                const parsedData = altData.slice(1).map(row => {
                  const obj = {};
                  headerRow.forEach((header, i) => {
                    if (header && row[i] !== undefined) obj[header] = row[i];
                  });
                  return obj;
                });
                
                // Add source file information to each record
                const enhancedData = parsedData.map(item => ({
                  ...item,
                  Original_Filename: file.name
                }));
                
                // Append to originalData
                originalData = [...originalData, ...enhancedData];
                logToConsole(`Parsed ${enhancedData.length} rows from ${file.name} using alternative method`);
              } else {
                logToConsole(`WARNING: Could not parse any data from ${file.name}`);
              }
            } else {
              // Add source file information to each record
              const enhancedData = fileData.map(item => ({
                ...item,
                Original_Filename: file.name
              }));
              
              // Append to originalData
              originalData = [...originalData, ...enhancedData];
              logToConsole(`Parsed ${enhancedData.length} rows from ${file.name}`);
            }
            
            // Update progress to completion for this file
            progressBar.style.width = `${fileProgress.end}%`;
            
            // Resolve the promise
            resolve();
            
          } catch (error) {
            statusElement.textContent = 'Error reading Excel file: ' + error.message;
            logToConsole(`Error reading ${file.name}: ${error.message}`);
            showToast(`Error reading ${file.name}: ${error.message}`, 'error');
            reject(error);
          }
        };
        
        reader.onerror = function(error) {
          statusElement.textContent = 'Error reading Excel file';
          logToConsole(`Error reading ${file.name}`);
          showToast(`Error reading ${file.name}`, 'error');
          reject(error);
        };
        
        reader.readAsArrayBuffer(file);
      });
    }
    
// Process PDF file
    function processPdfFileAsync(file, fileProgress) {
      return new Promise((resolve, reject) => {
        // Check if PDF.js is available
        if (typeof pdfjsLib === 'undefined') {
          logToConsole(`PDF.js library not available. Creating placeholder for ${file.name}`);
          
          // Create a placeholder record for this PDF file
          const fileId = `PDF-${file.name}-${Date.now()}`;
          const fileData = {
            Review_ID: fileId,
            Review_Title: file.name.replace('.pdf', ''),
            Review_Article_Text: "PDF content could not be extracted. PDF.js library not available.",
            Review_Type: 'PDF Document',
            Source_Language: 'Not Available',
            Target_Language: 'English',
            Review_Date: new Date().toLocaleDateString(),
            Original_Filename: file.name
          };
          
          // Add to combined data
          originalData.push(fileData);
          
          // Update progress
          progressBar.style.width = `${fileProgress.end}%`;
          
          showToast(`Added placeholder for PDF file ${file.name}`, 'warning');
          resolve();
          return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const typedArray = new Uint8Array(e.target.result);
            
            // Update initial progress
            progressBar.style.width = `${fileProgress.start + 5}%`;
            
            // Using pdf.js to extract text
            pdfjsLib.getDocument(typedArray).promise.then(function(pdf) {
              const numPages = pdf.numPages;
              
              logToConsole(`PDF has ${numPages} pages. Extracting text...`);
              progressBar.style.width = `${fileProgress.start + 10}%`;
              
              // Function to extract text from each page
              function extractPageText(pageNum) {
                return pdf.getPage(pageNum).then(function(page) {
                  return page.getTextContent();
                }).then(function(content) {
                  // Extract text items and join them
                  const strings = content.items.map(item => item.str);
                  return strings.join(' ');
                });
              }
              
              // Process all pages sequentially
              const extractionPromises = [];
              for(let i = 1; i <= numPages; i++) {
                extractionPromises.push(extractPageText(i));
              }
              
              Promise.all(extractionPromises).then(function(pageTexts) {
                // Combine all page texts
                const fullText = pageTexts.join('\n\n');
                
                logToConsole(`Successfully extracted ${fullText.length} characters from PDF ${file.name}`);
                
                // Create unique ID for this file
                const fileId = `PDF-${file.name}-${Date.now()}`;
                
                // Create data record for this file
                const fileData = {
                  Review_ID: fileId,
                  Review_Title: file.name.replace('.pdf', ''),
                  Review_Article_Text: fullText,
                  Review_Type: 'PDF Document',
                  Source_Language: 'Not Available',
                  Target_Language: 'English',
                  Review_Date: new Date().toLocaleDateString(),
                  Original_Filename: file.name
                };
                
                // Add to combined data
                originalData.push(fileData);
                
                // Update progress
                progressBar.style.width = `${fileProgress.end}%`;
                
                // Resolve the promise
                resolve();
              }).catch(function(error) {
                logToConsole(`Error processing PDF text in ${file.name}: ${error.message}`);
                statusElement.textContent = `Error processing PDF text in ${file.name}: ${error.message}`;
                reject(error);
              });
            }).catch(function(error) {
              logToConsole(`Error loading PDF ${file.name}: ${error.message}`);
              statusElement.textContent = `Error loading PDF ${file.name}: ${error.message}`;
              reject(error);
            });
            
          } catch (error) {
            statusElement.textContent = `Error processing PDF file ${file.name}: ${error.message}`;
            logToConsole(`Error: ${error.message}`);
            reject(error);
          }
        };
        
        reader.onerror = function(error) {
          statusElement.textContent = `Error reading PDF file ${file.name}`;
          reject(error);
        };
        
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Process Word file
    function processWordFileAsync(file, fileProgress) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            const arrayBuffer = e.target.result;
            
            // Update initial progress
            progressBar.style.width = `${fileProgress.start + 5}%`;
            statusElement.textContent = `Processing Word document ${file.name}...`;
            
            // Using mammoth.js to extract text
            mammoth.extractRawText({arrayBuffer: arrayBuffer})
              .then(function(result) {
                const text = result.value; // The raw text
                const messages = result.messages; // Any messages
                
                // Log any extraction messages
                if (messages.length > 0) {
                  logToConsole(`Mammoth messages for ${file.name}: ${messages.map(m => m.message).join('; ')}`);
                }
                
                // Create unique ID for this file
                const fileId = `DOC-${file.name}-${Date.now()}`;
                
                // Create data record for this file
                const fileData = {
                  Review_ID: fileId,
                  Review_Title: file.name.replace(/\.(docx|doc)$/, ''),
                  Review_Article_Text: text,
                  Review_Type: 'Word Document',
                  Source_Language: 'Not Available',
                  Target_Language: 'English',
                  Review_Date: new Date().toLocaleDateString(),
                  Original_Filename: file.name
                };
                
                // Add to combined data
                originalData.push(fileData);
                
                logToConsole(`Successfully extracted ${text.length} characters from Word document ${file.name}`);
                
                // Update progress
                progressBar.style.width = `${fileProgress.end}%`;
                
                // Resolve the promise
                resolve();
              })
              .catch(function(error) {
                logToConsole(`Error extracting text from Word document ${file.name}: ${error.message}`);
                statusElement.textContent = `Error extracting text from ${file.name}: ${error.message}`;
                reject(error);
              });
            
          } catch (error) {
            statusElement.textContent = `Error processing Word document ${file.name}: ${error.message}`;
            logToConsole(`Error: ${error.message}`);
            reject(error);
          }
        };
        
        reader.onerror = function(error) {
          statusElement.textContent = `Error reading Word document ${file.name}`;
          reject(error);
        };
        
        reader.readAsArrayBuffer(file);
      });
    }
    
    // Process image file
    function processImageFileAsync(file, fileProgress) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = function(e) {
          try {
            // Update initial progress
            progressBar.style.width = `${fileProgress.start + 5}%`;
            statusElement.textContent = `Processing image file ${file.name}...`;
            
            const image = new Image();
            image.src = e.target.result;
            
            image.onload = function() {
              // Create a canvas element
              const canvas = document.createElement('canvas');
              canvas.width = image.width;
              canvas.height = image.height;
              
              // Draw the image onto the canvas
              const ctx = canvas.getContext('2d');
              ctx.drawImage(image, 0, 0);
              
              // Get image data as a data URL
              const imageData = canvas.toDataURL('image/jpeg');
              
              // Update progress
              progressBar.style.width = `${fileProgress.start + 10}%`;
              
              // Use Tesseract.js for OCR
              Tesseract.recognize(
                imageData,
                'eng',
                { 
                  logger: m => {
                    if (m.status === 'recognizing text') {
                      // Update progress proportionally during OCR
                      const ocrProgress = fileProgress.start + 10 + (m.progress * (fileProgress.end - fileProgress.start - 10));
                      progressBar.style.width = `${ocrProgress}%`;
                      logToConsole(`OCR progress for ${file.name}: ${m.status} (${Math.round(m.progress * 100)}%)`);
                    }
                  }
                }
              ).then(({ data: { text } }) => {
                // Create unique ID for this file
                const fileId = `IMG-${file.name}-${Date.now()}`;
                
                // Create data record for this file
                const fileData = {
                  Review_ID: fileId,
                  Review_Title: file.name.replace(/\.(jpg|jpeg|png|gif)$/, ''),
                  Review_Article_Text: text,
                  Review_Type: 'Image OCR',
                  Source_Language: 'Not Available',
                  Target_Language: 'English',
                  Review_Date: new Date().toLocaleDateString(),
                  Original_Filename: file.name,
                  Image_URL: URL.createObjectURL(file)
                };
                
                // Add to combined data
                originalData.push(fileData);
                
                logToConsole(`Successfully extracted ${text.length} characters via OCR from ${file.name}`);
                
                // Update progress
                progressBar.style.width = `${fileProgress.end}%`;
                
                // Resolve the promise
                resolve();
              }).catch(error => {
                logToConsole(`OCR Error for ${file.name}: ${error.message}`);
                statusElement.textContent = `OCR Error for ${file.name}: ${error.message}`;
                reject(error);
              });
            };
            
            image.onerror = function(error) {
              logToConsole(`Error loading image ${file.name}`);
              statusElement.textContent = `Error loading image ${file.name}`;
              reject(new Error("Failed to load image"));
            };
            
          } catch (error) {
            statusElement.textContent = `Error processing image file ${file.name}: ${error.message}`;
            logToConsole(`Error: ${error.message}`);
            reject(error);
          }
        };
        
        reader.onerror = function(error) {
          statusElement.textContent = `Error reading image file ${file.name}`;
          reject(error);
        };
        
        reader.readAsDataURL(file);
      });
    }
    
    // Initialize extracted data (renamed to avoid function signature mismatch)
    function finalizeDataPreparation() {
      // This function is called after all files are processed
      
      // Check if we have actual data
      if (!originalData || originalData.length === 0) {
        logToConsole("ERROR: Could not parse any data from the files");
        statusElement.textContent = 'Error: No data found in the files';
        progressBar.style.width = '0%';
        return;
      }
      
      // Log a sample of the first row to understand data structure
      logToConsole("Sample first row: " + JSON.stringify(originalData[0]));
      
      // Make sure all items are objects
      originalData = originalData.filter(item => item && typeof item === 'object');
      
      // Add Review_ID if not present and ensure uniqueness across multiple files
      const highestExistingId = originalData
        .filter(item => item.Review_ID && item.Review_ID.startsWith('TR'))
        .map(item => parseInt(item.Review_ID.replace('TR', '')) || 0)
        .reduce((max, id) => Math.max(max, id), 0);
      
      let nextId = highestExistingId + 1;
      
      originalData = originalData.map(item => {
        if (!item.Review_ID && !item.StoreId) {
          item.Review_ID = `TR${nextId++}`;
        }
        return item;
      });
      
      // Remove any potential duplicates from input data based on StoreId or Review_ID
      const uniqueIds = new Set();
      originalData = originalData.filter(item => {
        // Ensure we have a valid ID or generate one if missing
        const id = item.StoreId || item.Review_ID || `AUTO${Math.random().toString(36).substring(2, 9)}`;
        item.Review_ID = item.Review_ID || id; // Ensure Review_ID is set
        
        if (uniqueIds.has(id)) return false;
        uniqueIds.add(id);
        return true;
      });
      
      totalReviews = originalData.length;
      
      logToConsole(`Loaded ${totalReviews} unique items from ${window.totalFileCount} files`);
      statusElement.textContent = `${window.totalFileCount} files loaded with ${totalReviews} unique items`;
      progressBar.style.width = '30%';
      
      // Show toast notification
      showToast(`Successfully loaded ${totalReviews} items from ${window.totalFileCount} files`, 'success');
      
      checkStartButtonState();
    }
    
    // Check if start button should be enabled
    function checkStartButtonState() {
      startProcessingBtn.disabled = !(apiKey && originalData && originalData.length > 0 && !processing);
    }
    
    // Start processing
    function startProcessing() {
      if (!apiKey) {
        alert("Please enter your OpenAI API key first");
        return;
      }
      
      if (!originalData || originalData.length === 0) {
        alert("Please upload a file first");
        return;
      }
      
      processing = true;
      processingPaused = false;
      processedData = [];
      processedIds.clear(); // Clear the tracking set
      processedReviews = 0;
      currentBatch = 0;
      
      startProcessingBtn.disabled = true;
      pauseProcessingBtn.disabled = false;
      resumeProcessingBtn.disabled = true;
      downloadCurrentBtn.disabled = true;
      downloadCSVBtn.disabled = true;
      
      progressBar.style.width = '30%';
      progressLabel.textContent = `0 / ${totalReviews} reviews processed`;
      
      logToConsole("Starting enhanced processing of historical book reviews...");
      showToast('Started processing reviews', 'info');
      processNextBatch();
    }
    
    // Pause processing
    function pauseProcessing() {
      processingPaused = true;
      pauseProcessingBtn.disabled = true;
      resumeProcessingBtn.disabled = false;
      logToConsole("Processing paused");
      statusElement.textContent = "Processing paused";
      showToast('Processing paused', 'info');
    }
    
    // Resume processing
    function resumeProcessing() {
      processingPaused = false;
      pauseProcessingBtn.disabled = false;
      resumeProcessingBtn.disabled = true;
      logToConsole("Processing resumed");
      statusElement.textContent = "Processing resumed";
      showToast('Processing resumed', 'info');
      processNextBatch();
    }
    
    // Process next batch of reviews
    async function processNextBatch() {
      if (processingPaused || currentBatch >= originalData.length) {
        if (currentBatch >= originalData.length) {
          // Processing complete
          processing = false;
          logToConsole("Processing complete!");
          statusElement.textContent = `Processing complete. Extracted data for ${processedData.length} reviews.`;
          progressBar.style.width = '100%';
          
          displayResults();
          startProcessingBtn.disabled = false;
          pauseProcessingBtn.disabled = true;
          resumeProcessingBtn.disabled = true;
          downloadCurrentBtn.disabled = false;
          downloadCSVBtn.disabled = false;
          
          // Show toast notification
          showToast(`Processing complete. Extracted ${processedData.length} reviews.`, 'success');
          
          // Initialize data visualization for the dashboard tab
          createDataDashboard();
        }
        return;
      }
      
      // Calculate dynamic batch size based on dataset size
      let batchSize = parseInt(batchSizeInput.value);
      const totalSize = originalData.length;
      
      // For very large datasets, we may need to adjust the batch size
      if (totalSize > 1000) {
        // Use a smaller batch size for large datasets to avoid overwhelming the system
        const recommendedBatchSize = Math.max(1, Math.min(batchSize, Math.floor(5000 / totalSize)));
        if (recommendedBatchSize < batchSize) {
          logToConsole(`Large dataset detected (${totalSize} items). Recommended batch size: ${recommendedBatchSize}`);
          if (!batchSizeAdjusted) {
            batchSizeInput.value = recommendedBatchSize;
            batchSize = recommendedBatchSize;
            batchSizeAdjusted = true;
          }
        }
      }
      
      const endBatch = Math.min(currentBatch + batchSize, originalData.length);
      
      statusElement.textContent = `Processing reviews ${currentBatch + 1} to ${endBatch} of ${totalReviews}...`;
      
      const batchPromises = [];
      for (let i = currentBatch; i < endBatch; i++) {
        batchPromises.push(processReviewWithLLM(originalData[i], i));
      }
      
      try {
        // Add delay between API calls to avoid rate limiting
        if (totalSize > 100) {
          // Stagger the API calls with a small delay between each
          for (let i = 0; i < batchPromises.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay between API calls
            batchPromises[i].catch(error => {
              logToConsole(`Error in batch item ${currentBatch + i + 1}: ${error.message}`);
            });
          }
        }
        
        await Promise.all(batchPromises);
        
        // Update progress
        currentBatch = endBatch;
        const percentComplete = (processedReviews / totalReviews) * 100;
        progressBar.style.width = `${30 + (percentComplete * 0.7)}%`;
        progressLabel.textContent = `${processedReviews} / ${totalReviews} reviews processed`;
        
        // Enable download of partial results
        if (processedData.length > 0) {
          downloadCurrentBtn.disabled = false;
          downloadCSVBtn.disabled = false;
        }
        
        // Add a small delay between batches for large datasets
        if (totalSize > 100) {
          await new Promise(resolve => setTimeout(resolve, 1000)); // 1s delay between batches
        }
        
        // Process next batch
        processNextBatch();
      } catch (error) {
        logToConsole("Error in batch processing: " + error.message);
        statusElement.textContent = "Error in processing: " + error.message;
        
        // Show toast notification
        showToast('Error in processing: ' + error.message, 'error');
        
        // Allow resuming after error
        pauseProcessingBtn.disabled = true;
        resumeProcessingBtn.disabled = false;
        processingPaused = true;
        
        // Enable download of partial results
        if (processedData.length > 0) {
          downloadCurrentBtn.disabled = false;
          downloadCSVBtn.disabled = false;
        }
      }
    }
    
    // Process a single review with the LLM
    async function processReviewWithLLM(review, index) {
      try {
        // Get the review ID to check for duplicates
        const reviewId = review.StoreId || review.Review_ID || `TR${index+1}`;
        
        // Skip if this review has already been processed
        if (processedIds.has(reviewId)) {
          logToConsole(`Skipping duplicate review ${reviewId}`);
          processedReviews++;
          return;
        }
        
        // Extract the key fields from the review, checking for various possible field names
        const reviewTitle = review["Review Title"] || review.Review_Title || review.Title || "";
        const reviewArticleText = review["Review Article Text"] || review.Review_Article_Text || review.Review_Full_Text || review.Full_Text || "";
        const reviewAbstract = review.Abstract || review.Review_Abstract || "";
        const reviewDate = review["Review Publication Date"] || review.Review_Date || review.pubdate || review.Date || "";
        const reviewYear = review["Review Year"] || review.Review_Year || review.Year || (reviewDate ? new Date(reviewDate).getFullYear() : "");
        const reviewAuthor = review["Review Author"] || review.Review_Author || review.Author || "";
        const reviewPublication = review.Review_Publication || review.pubtitle || "New York Times";
        
        // Get URL information - check all possible URL fields
        const reviewURL = review["Document URL"] || review["Review URL"] || review.Review_URL || review.DocumentURL || review["Find A Copy"] || review.Find_A_Copy || "";
        
        // Debug logging
        if (debugModeCheckbox.checked) {
          logToConsole(`DEBUG - Review Data for ${index + 1}:`);
          logToConsole(`DEBUG - Title: ${reviewTitle}`);
          logToConsole(`DEBUG - Text Length: ${reviewArticleText ? reviewArticleText.length : 0} chars`);
          logToConsole(`DEBUG - Abstract Length: ${reviewAbstract ? reviewAbstract.length : 0} chars`);
          logToConsole(`DEBUG - Date: ${reviewDate}`);
          logToConsole(`DEBUG - Year: ${reviewYear}`);
          logToConsole(`DEBUG - Author: ${reviewAuthor}`);
          logToConsole(`DEBUG - URL: ${reviewURL}`);
          
          // Log the raw review object for debugging
          logToConsole(`DEBUG - Raw review object keys: ${Object.keys(review).join(', ')}`);
          logToConsole(`DEBUG - Raw review data sample: ${JSON.stringify(review).substring(0, 200)}...`);
        }
        
        // Pre-analysis to detect if it's likely a translation based on the content
        const isLikelyTranslation = analyzeForTranslationIndicators(reviewTitle, reviewArticleText, reviewAbstract);
        
        // Check if we should assume all reviews are translations
        const assumeTranslated = assumeTranslatedCheckbox.checked || isLikelyTranslation;
        
        // Check if we have any content to analyze
        const hasContent = reviewTitle || reviewArticleText || reviewAbstract;
        
        if (!hasContent) {
          logToConsole(`Review ${index + 1} has no content to analyze - skipping`);
          processedReviews++;
          return;
        }
        
        // If we're assuming all are translated or we have valid content, proceed
        if (assumeTranslated && !assumeFullAIProcessing.checked) {
          logToConsole(`Processing review ${index + 1} as a translation (${isLikelyTranslation ? 'detected' : 'assumed'}): "${truncateText(reviewTitle, 40)}"`);
          
          // Create default data for assumed translations
          processExtractedData({
            IsTranslatedBookReview: true,
            Translated_Title: reviewTitle || "Not Available",
            Author_Name: "Not Available",
            Translator_Name: "Not Available",
            Source_Language: "Not Available"
          }, reviewId, review, reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewURL, index);
          
          return;
        }
        
        // Create enhanced prompt with the updated fields
        const prompt = createEnhancedPrompt(reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewPublication);
        
        logToConsole(`Processing review ${index + 1} with AI: "${truncateText(reviewTitle, 40)}"`);
        
        // Call the OpenAI API
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: modelSelect.value,
            messages: [{"role": "user", "content": prompt}],
            temperature: parseFloat(temperatureInput.value) / 10
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(`API error: ${errorData.error?.message || 'Unknown error'}`);
        }
        
        const data = await response.json();
        
        // Debug logging of API response
        if (debugModeCheckbox.checked) {
          logToConsole(`DEBUG - API Response for ${index + 1}:`);
          logToConsole(`DEBUG - Response: ${data.choices[0].message.content.substring(0, 100)}...`);
        }
        
        // Parse the response
        try {
          const extractedData = JSON.parse(data.choices[0].message.content);
          
          // Check if this is actually a translated book review
          if (extractedData.IsTranslatedBookReview === false) {
            if (debugModeCheckbox.checked) {
              logToConsole(`DEBUG - Review ${index + 1} identified as non-translation by AI`);
            }
            
            // Even if AI says it's not a translation, if assume translated is checked, we process it anyway
            if (assumeTranslated) {
              logToConsole(`Overriding AI decision and processing review ${index + 1} as a translation`);
              extractedData.IsTranslatedBookReview = true;
            } else {
              logToConsole(`Review ${index + 1} is not about a translated book - skipping`);
              processedReviews++;
              return;
            }
          }
          
          // Generate confidence scores for each field if enabled
          if (confidenceScoringCheckbox.checked) {
            addConfidenceScores(extractedData, reviewTitle, reviewArticleText, reviewAbstract);
          }
          
          // Add null check before processing extracted data
          if (extractedData) {
            processExtractedData(extractedData, reviewId, review, reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewURL, index);
          } else {
            logToConsole(`Error: Extracted data is null or undefined for review ${index + 1}`);
            processedReviews++;
          }
          
        } catch (parseError) {
          logToConsole(`Error parsing LLM response for review ${index + 1}: ${parseError.message}`);
          
          if (debugModeCheckbox.checked) {
            logToConsole(`DEBUG - Failed Response: ${data.choices[0].message.content}`);
          }
          
          // If we can't parse the response but assume translated is checked, we still process it
          if (assumeTranslated) {
            logToConsole(`Despite parsing error, processing review ${index + 1} as a translation`);
            processExtractedData({
              IsTranslatedBookReview: true,
              Translated_Title: reviewTitle || "Not Available",
              Author_Name: "Not Available",
              Translator_Name: "Not Available",
              Source_Language: "Not Available"
            }, reviewId, review, reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewURL, index);
          } else {
            // We'll still count it as processed
            processedReviews++;
          }
        }
      } catch (error) {
        logToConsole(`Error processing review ${index + 1}: ${error.message}`);
        
        // If assume translated is checked, we still process it despite errors
        if (assumeTranslatedCheckbox.checked) {
          logToConsole(`Despite error, processing review ${index + 1} as a translation`);
          const reviewURL = review["Document URL"] || review["Review URL"] || review.Review_URL || review.DocumentURL || review["Find A Copy"] || review.Find_A_Copy || "";
          processExtractedData({
            IsTranslatedBookReview: true,
            Translated_Title: review["Review Title"] || review.Review_Title || review.Title || "Not Available",
            Author_Name: "Not Available",
            Translator_Name: "Not Available",
            Source_Language: "Not Available"
          }, review.StoreId || review.Review_ID || `TR${index+1}`, review, 
          review["Review Title"] || review.Review_Title || review.Title || "", 
          review["Review Article Text"] || review.Review_Article_Text || review.Review_Full_Text || review.Full_Text || "", 
          review.Abstract || review.Review_Abstract || "", 
          review["Review Publication Date"] || review.Review_Date || review.pubdate || review.Date || "", 
          review["Review Year"] || review.Review_Year || review.Year || "", 
          review["Review Author"] || review.Review_Author || review.Author || "", 
          reviewURL,
          index);
          return;
        }
        
        throw error; // Propagate the error to handle batch pausing
      }
    }
    
    // Add confidence scores to the extracted data fields
    function addConfidenceScores(extractedData, reviewTitle, reviewArticleText, reviewAbstract) {
      const combinedText = `${reviewTitle} ${reviewAbstract} ${reviewArticleText}`;
      const confidenceScores = {};
      
      // Define patterns for confidence scoring
      const fieldPatterns = {
        'Author_Name': {
          high: [
            /by\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i, 
            /author[\s,:]+([A-Z][a-z]+\s+[A-Z][a-z]+)/i,
            /([A-Z][a-z]+\s+[A-Z][a-z]+),\s+the\s+author/i
          ],
          medium: [/[A-Z][a-z]+\s+[A-Z][a-z]+/]
        },
        'Translator_Name': {
          high: [
            /translated\s+by\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i,
            /translator[\s,:]+([A-Z][a-z]+\s+[A-Z][a-z]+)/i
          ],
          medium: [
            /translated\s+by/i,
            /translation\s+by/i
          ]
        },
        'Source_Language': {
          high: [
            /from\s+the\s+(\w+)/i,
            /translated\s+from\s+(?:the\s+)?(\w+)/i,
            /original\s+(\w+)\s+(?:text|version)/i
          ],
          medium: [
            /(\w+)\s+(?:author|writer)/i,
            /(?:German|French|Russian|Italian|Spanish|Japanese|Chinese)/i
          ]
        },
        'Translated_Title': {
          high: [
            /"([^"]+)"/,
            /'([^']+)'/,
            /titled\s+["']([^"']+)["']/i
          ],
          medium: [/[A-Z][^.!?]*[.!?]/]
        }
      };
      
      // Analyze each field
      for (const field in extractedData) {
        if (field === 'IsTranslatedBookReview') continue;
        
        // Skip empty fields
        if (!extractedData[field] || extractedData[field] === "Not Available" || extractedData[field] === "Not Mentioned") {
          confidenceScores[field] = 0.1; // Very low confidence for unavailable data
          continue;
        }
        
        // Check if the field value appears in the text
        const fieldValue = extractedData[field].toString();
        const valueInText = combinedText.includes(fieldValue) && fieldValue.length > 3;
        
        // Default medium confidence
        let score = valueInText ? 0.7 : 0.5;
        
        // Check specific patterns for key fields
        if (fieldPatterns[field]) {
          // Check high confidence patterns
          for (const pattern of fieldPatterns[field].high || []) {
            if (pattern.test(combinedText)) {
              score = Math.max(score, 0.9);
              break;
            }
          }
          
          // Check medium confidence patterns
          for (const pattern of fieldPatterns[field].medium || []) {
            if (pattern.test(combinedText)) {
              score = Math.max(score, 0.7);
              break;
            }
          }
        }
        
        // Additional adjustments for specific fields
        if (field === 'Target_Language' && extractedData[field] === 'English') {
          score = 0.95; // Very high confidence since this is almost always English for NYT
        }
        
        // Adjust scores based on value specificity
        if (fieldValue.length > 50) {
          // Long values get reduced confidence
          score = Math.min(score, 0.7);
        }
        
        // Set the final confidence score
        confidenceScores[field] = score;
      }
      
      // Add confidence scores to the data
      extractedData._confidenceScores = confidenceScores;
    }
    
    // Analyze text for translation indicators
    function analyzeForTranslationIndicators(title, text, abstract) {
      const combinedText = `${title} ${text} ${abstract}`.toLowerCase();
      
      // Look for explicit translation indicators
      const explicitIndicators = [
        /translat(ed|ion|or)/i,
        /render(ed|ing)?\s+(into|in|from)/i,
        /english\s+version/i,
        /from\s+the\s+(original\s+)?(german|french|italian|spanish|russian|japanese|chinese|arabic|portuguese|dutch|greek|latin|swedish|norwegian|danish|finnish|czech|polish|hungarian|turkish)/i,
        /version\s+of\s+the\s+original/i
      ];
      
      // Look for foreign author names or works
      const foreignIndicators = [
        /tolstoi|tolstoy|dostoyevsky|dostoevsky|pushkin|chekhov|gogol|turgenev|tourgenef|gorky|andreyev/i, // Russian
        /dumas|hugo|balzac|flaubert|zola|maupassant|verne|proust|camus|sartre|beauvoir/i, // French
        /goethe|schiller|mann|kafka|hesse|remarque|brecht|rilke|grass|b√∂ll/i, // German
        /cervantes|garcia\s+marquez|m√°rquez|borges|neruda|paz|allende|lorca|unamuno/i, // Spanish/Latin American
        /dante|eco|calvino|pirandello|moravia|levi|ferrante/i, // Italian
        /ibsen|hamsun|undset|bj√∏rnson|bjornson/i, // Norwegian
        /andersen|kierkegaard/i, // Danish
        /strindberg|lagerl√∂f|lagerlof/i, // Swedish
        /sienkiewicz|milosz|szymborska|gombrowicz|lem/i, // Polish
        /homer|sophocles|euripides|aeschylus|plato|aristotle/i, // Ancient Greek
        /virgil|cicero|ovid|horace|seneca|marcus\s+aurelius/i // Latin/Roman
      ];
      
      // Look for foreign place or cultural references
      const culturalIndicators = [
        /\b(paris|berlin|moscow|rome|madrid|vienna|tokyo|beijing|cairo|athens)\b/i,
        /\b(france|germany|russia|italy|spain|austria|japan|china|egypt|greece)\b/i,
        /\b(french|german|russian|italian|spanish|austrian|japanese|chinese|egyptian|greek)\b/i
      ];
      
      // Check for explicit indicators
      for (const regex of explicitIndicators) {
        if (regex.test(combinedText)) {
          return true;
        }
      }
      
      // Check for foreign authors/works
      for (const regex of foreignIndicators) {
        if (regex.test(combinedText)) {
          return true;
        }
      }
      
      // Check for cultural references
      for (const regex of culturalIndicators) {
        if (regex.test(combinedText)) {
          return true;
        }
      }
      
      // No strong indicators found
      return false;
    }
    
    // Process the extracted data
    function processExtractedData(extractedData, reviewId, review, reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewURL, index) {
      // Ensure we have valid input data before proceeding
      if (!extractedData || !reviewId) {
        logToConsole(`Error: Missing required data for review ${index}`);
        processedReviews++;
        return;
      }
      
      // Mark this review ID as processed
      processedIds.add(reviewId);
      
      // Make a deep copy to avoid modifying the original data
      const extractedDataCopy = JSON.parse(JSON.stringify(extractedData));
      
      // Remove the flag field
      delete extractedDataCopy.IsTranslatedBookReview;
      
      // Identify the review type from title and content
      const reviewType = identifyReviewType(reviewTitle, reviewArticleText);
      
      // Calculate additional meta columns
      const wordCount = countWords(reviewArticleText);
      const mentionsTranslatorInFirstPara = checkTranslatorInFirstParagraph(reviewArticleText);
      const mentionsTranslationInTitle = checkTranslationInTitle(reviewTitle);
      
      // Merge the extracted data with the original review data
      const mergedData = {
        ...review,
        ...extractedDataCopy,
        Review_ID: reviewId,
        Review_Title: reviewTitle || "Not Available",
        Review_Date: reviewDate || "Not Available",
        Review_Year: reviewYear || "Not Available",
        Review_Type: reviewType,
        Review_URL: reviewURL || "Not Available",
        Review_Article_Text: reviewArticleText || "Not Available",
        Review_Abstract: reviewAbstract || "Not Available",
        Review_Author: reviewAuthor || "Not Available",
        Review_Word_Count: wordCount,
        Mentions_Translator_In_First_Paragraph: mentionsTranslatorInFirstPara,
        Mentions_Translation_In_Title: mentionsTranslationInTitle
      };
      
      // Check if there are any inferred fields that could be added
      enrichReviewData(mergedData);
      
      // Add to processed data
      processedData.push(mergedData);
      processedReviews++;
      
      logToConsole(`Successfully processed translated book review ${index + 1} (${reviewType})`);
    }
    
    // Identify the type of review from title and content
    function identifyReviewType(title, content) {
      // Convert to lowercase for pattern matching
      const titleLower = (title || "").toLowerCase();
      const contentLower = (content || "").toLowerCase();
      
      // Define patterns for different review types with weights
      const reviewTypePatterns = [
        // Full-Length Review patterns
        {
          type: 'Full-Length Review',
          titlePatterns: [
            /review of books/i,
            /^reviews of books/i,
            /fiction of the season/i,
            /fiction of the autumn/i,
            /book review/i,
            /^review/i,
            /books of the times/i,
            /in review/i
          ],
          contentPatterns: [
            /in this detailed (review|analysis)/i,
            /the reviewer finds/i,
            /this comprehensive (review|examination)/i
          ],
          contentLength: 1000 // If content is longer than this, it's more likely a full review
        },
        
        // Short Notice patterns
        {
          type: 'Short Notice',
          titlePatterns: [
            /^notes and news/i,
            /literary notes/i,
            /book notes/i,
            /^notes /i,
            /^notices of new books/i,
            /literary notice/i,
            /^notices/i,
            /brief mention/i
          ],
          contentPatterns: [
            /brief notice/i,
            /short mention/i,
            /recently published/i
          ],
          contentLength: 500 // If content is shorter than this, it might be a short notice
        },
        
        // Announcement patterns
        {
          type: 'Announcement',
          titlePatterns: [
            /^new books/i,
            /^new publications/i,
            /forthcoming/i,
            /^books and authors/i,
            /holiday books/i,
            /books for summer/i,
            /season\'s books/i,
            /will be published/i,
            /announces the publication/i
          ],
          contentPatterns: [
            /will be published/i,
            /forthcoming/i,
            /announced/i,
            /is preparing/i,
            /in preparation/i
          ]
        },
        
        // Opinion Editorial patterns
        {
          type: 'Opinion Editorial',
          titlePatterns: [
            /editorial/i,
            /opinion/i,
            /viewpoint/i,
            /commentary/i
          ],
          contentPatterns: [
            /in my opinion/i,
            /in this editor's view/i,
            /it is our belief/i
          ]
        },
        
        // Author Interview patterns
        {
          type: 'Author Interview',
          titlePatterns: [
            /interview/i,
            /conversation with/i,
            /profile of/i,
            /meets/i,
            /talking with/i
          ],
          contentPatterns: [
            /in conversation with/i,
            /during the interview/i,
            /when asked about/i,
            /the author explained/i,
            /said in an interview/i
          ]
        },
        
        // Round-up patterns
        {
          type: 'Round-up',
          titlePatterns: [
            /round(-|\s)up/i,
            /multiple titles/i,
            /several books/i,
            /collection of/i,
            /books for gifts/i,
            /\d+ books/i
          ],
          contentPatterns: [
            /among the books/i,
            /several titles/i,
            /various books/i,
            /included in this list/i
          ]
        }
      ];
      
      // Calculate scores for each review type
      const scores = {};
      
      reviewTypePatterns.forEach(typeInfo => {
        let score = 0;
        
        // Check title patterns
        typeInfo.titlePatterns.forEach(pattern => {
          if (pattern.test(titleLower)) {
            score += 2; // Title matches are stronger indicators
          }
        });
        
        // Check content patterns
        if (contentLower) {
          typeInfo.contentPatterns?.forEach(pattern => {
            if (pattern.test(contentLower)) {
              score += 1;
            }
          });
          
          // Check content length if specified
          if (typeInfo.contentLength) {
            if (typeInfo.type === 'Full-Length Review' && contentLower.length > typeInfo.contentLength) {
              score += 1;
            } else if (typeInfo.type === 'Short Notice' && contentLower.length < typeInfo.contentLength) {
              score += 1;
            }
          }
        }
        
        scores[typeInfo.type] = score;
      });
      
      // Find the type with the highest score
      let bestType = 'Other';
      let bestScore = 0;
      
      Object.entries(scores).forEach(([type, score]) => {
        if (score > bestScore) {
          bestType = type;
          bestScore = score;
        }
      });
      
      return bestType;
    }
    
    // Get the CSS class for the review type badge
    function getReviewTypeClass(type) {
      switch(type) {
        case 'Full-Length Review':
          return 'type-formal-review';
        case 'Short Notice':
          return 'type-notes';
        case 'Announcement':
          return 'type-announcement';
        case 'Opinion Editorial':
          return 'type-other';
        case 'Author Interview':
          return 'type-news';
        case 'Round-up':
          return 'type-news';
        default:
          return 'type-other';
      }
    }
    
    // Analyze the first paragraph of a review for translator mentions
    function checkTranslatorInFirstParagraph(text) {
      if (!text) return "No";
      
      // Get the first paragraph (stopping at double line break or first 500 chars)
      const firstPara = text.split(/\n\s*\n/)[0].substring(0, 500);
      
      // Check for translator-related words
      const translatorTerms = [
        /translat(ed|ion|or)/i,
        /render(ed|ing)?\s+(into|in)\s+English/i,
        /English\s+version/i
      ];
      
      for (const regex of translatorTerms) {
        if (regex.test(firstPara)) {
          return "Yes";
        }
      }
      
      return "No";
    }
    
    // Check if translation is mentioned in the title
    function checkTranslationInTitle(title) {
      if (!title) return "No";
      
      const translationTerms = [
        /translat(ed|ion|or)/i,
        /English\s+version/i,
        /render(ed|ing)/i,
        /foreign/i
      ];
      
      for (const regex of translationTerms) {
        if (regex.test(title)) {
          return "Yes";
        }
      }
      
      return "No";
    }
    
    // Count words in a string
    function countWords(text) {
      if (!text) return 0;
      return text.split(/\s+/).filter(word => word.length > 0).length;
    }
    
    // Enrich review data with inferred information
    function enrichReviewData(reviewData) {
      // If we have author nationality but no source language, we can sometimes infer it
      if ((reviewData.Author_Nationality && reviewData.Author_Nationality !== "Not Available" && reviewData.Author_Nationality !== "Not Mentioned") && 
          (!reviewData.Source_Language || reviewData.Source_Language === "Not Available" || reviewData.Source_Language === "Not Mentioned")) {
        
        // Map of nationalities to potential source languages
        const nationalityToLanguage = {
          'French': 'French',
          'German': 'German',
          'Russian': 'Russian',
          'Spanish': 'Spanish',
          'Italian': 'Italian',
          'Norwegian': 'Norwegian',
          'Swedish': 'Swedish',
          'Danish': 'Danish',
          'Polish': 'Polish',
          'Czech': 'Czech',
          'Hungarian': 'Hungarian',
          'Dutch': 'Dutch',
          'Portuguese': 'Portuguese',
          'Japanese': 'Japanese',
          'Chinese': 'Chinese',
          'Greek': 'Greek'
        };
        
        if (nationalityToLanguage[reviewData.Author_Nationality]) {
          reviewData.Source_Language = nationalityToLanguage[reviewData.Author_Nationality];
          if (debugModeCheckbox && debugModeCheckbox.checked) {
            logToConsole(`DEBUG - Inferred source language ${reviewData.Source_Language} from nationality ${reviewData.Author_Nationality}`);
          }
        }
      }
      
      // If target language is not specified, default to English for NYT reviews
      if (!reviewData.Target_Language || reviewData.Target_Language === "Not Available" || reviewData.Target_Language === "Not Mentioned") {
        reviewData.Target_Language = "English";
      }
      
      // If we have a date but no year, extract the year
      if ((!reviewData.Review_Year || reviewData.Review_Year === "Not Available") && reviewData.Review_Date) {
        const dateMatch = reviewData.Review_Date.match(/\d{4}/);
        if (dateMatch) {
          reviewData.Review_Year = dateMatch[0];
        }
      }
      
      // For 19th century NYT reviews, we can often infer Translation_Publication_Year if not specified
      if ((!reviewData.Translation_Publication_Year || reviewData.Translation_Publication_Year === "Not Available" || reviewData.Translation_Publication_Year === "Not Mentioned") && 
          reviewData.Review_Year && reviewData.Translation_Status) {
        
        const status = reviewData.Translation_Status.toLowerCase();
        if (status.includes('forthcoming') || status.includes('announced')) {
          // Forthcoming works would typically be published within a year
          reviewData.Translation_Publication_Year = (parseInt(reviewData.Review_Year) + 1).toString();
        } else if (status.includes('recent') || status.includes('new')) {
          // Recent works would typically be from the same year or the year before
          reviewData.Translation_Publication_Year = reviewData.Review_Year;
        }
      }
      
      return reviewData;
    }
    
    // Create enhanced prompt with all the required fields
    function createEnhancedPrompt(reviewTitle, reviewArticleText, reviewAbstract, reviewDate, reviewYear, reviewAuthor, reviewPublication) {
      // First, determine the available content
      const hasTitle = !!reviewTitle?.trim();
      const hasFullText = !!reviewArticleText?.trim();
      const hasAbstract = !!reviewAbstract?.trim();
      
      // Content prioritization message
      let contentMessage = "";
      if (hasFullText) {
        contentMessage = "I'm providing the full review article text which contains the most information.";
      } else if (hasAbstract) {
        contentMessage = "The full article text is not available, but I'm providing the abstract which contains key information.";
      } else if (hasTitle) {
        contentMessage = "Only the review title is available. Please extract what you can from this limited information.";
      }
      
      return `You are a specialized expert in historical book reviews and translation studies. Your task is to analyze this historical New York Times review and extract detailed information about translated works.

REVIEW DATA:
Title: "${reviewTitle}"
Full Review Article Text: "${reviewArticleText}"
Abstract: "${reviewAbstract}"
Date: ${reviewDate}
Year: ${reviewYear}
Author: ${reviewAuthor}
Publication: ${reviewPublication || "New York Times"}

${contentMessage}

IMPORTANT CONTEXT: 
This review is almost certainly about a translated book. The NYT corpus you're analyzing focuses specifically on book reviews of translated works from the 19th century. Even if the translation aspect is not explicitly mentioned, you should look for subtle clues like:
- Foreign author names
- References to works originally written in another language
- Mentions of foreign literary traditions or contexts
- Brief references to translation quality that might be easy to miss
- Descriptions that imply the work has been moved across languages or cultures

EXAMPLE 1:
Review Title: "NOTES AND NEWS.: A NEW NOVEL BY THE AUTHOR OF 'QUO VADIS.'"
Review Text: "The Knights of the cross," by Henryk Sienkiewicz, the author of "Quo Vadis," the writing of which has been delayed for several months, will shortly be in form for publication both here and abroad. The authorized American edition of the first part, translated with the author's sanction by Jeremiah Curtin, will be presented immediately by Little, Brown & Co. Mr. Curtin's work as a translator, illustrated through "Quo Vadis," "With Fire and Sword," "The Deluge," and "Pan-Michael," needs no comment here."

In Example 1, you should extract:
- Translated_Title: "The Knights of the cross"
- Author_Name: "Henryk Sienkiewicz"
- Translator_Name: "Jeremiah Curtin"
- Translation_Publisher: "Little, Brown & Co."
- Translator_Visibility: "Prominently Featured" (since his previous work is mentioned)
- Edition_Information: "authorized American edition"
- Translation_Status: "forthcoming/announced"
- Translator_Previous_Works: "Quo Vadis, With Fire and Sword, The Deluge, Pan-Michael"
- Author_Previous_Works: "Quo Vadis"
- Author_Recognition: "Well-known" (implied by referencing previous work)
- Genre_Category: "Novel"
- Quoted_Passages_About_Translation: "Mr. Curtin's work as a translator, illustrated through 'Quo Vadis,' 'With Fire and Sword,' 'The Deluge,' and 'Pan-Michael,' needs no comment here."
- Translator_Framing_Strategy: "expert"
- Mentions_Translation_In_Title: "No"

EXAMPLE 2:
Review Title: "TOLSTOI.: A BOOK FROM THE RUSSIAN TELLING HOW HE LIVES AND WORKS.*"
Review Text: "Miss Isabel F. Hapgood has long been known as an efficient Russian scholar, and has done not a little to familiarize us with the life and literature of the great race which is now the rival of our own for the political supremacy of the world. Her latest volume, a translation of Sergyeenko's "How Count Tolstoi Lives and Works," will prove welcome reading to all who are interested in the truly remarkable man who is its subject."

In Example 2, you should extract:
- Translated_Title: "How Count Tolstoi Lives and Works"
- Author_Name: "Sergyeenko" (original author)
- Subject_Of_Work: "Count Tolstoi"
- Translator_Name: "Isabel F. Hapgood"
- Translator_Recognition: "Efficient Russian scholar"
- Source_Language: "Russian" (clearly stated)
- Translator_Previous_Works: Referenced but not named specifically
- Reception_Of_Translation: "will prove welcome reading"
- Genre_Category: "Biography"
- Translation_Status: "recently published"
- Quoted_Passages_About_Translation: "Miss Isabel F. Hapgood has long been known as an efficient Russian scholar, and has done not a little to familiarize us with the life and literature of the great race"
- Reviewer_Tone_Toward_Translation: "appreciative"
- Critical_Vocabulary_About_Translation: "efficient"
- Translator_Framing_Strategy: "expert"
- Presence_Of_Reviewer_Multilingualism: "Not Mentioned"

EXAMPLE 3: (Very minimal translation information)
Review Title: "A NOVEL OF NORWAY.: THE BATTLE OF WATERLOO, FAITHFULLY RENDERED FROM THE FRENCH."
Review Text: "Bjornson's new tale turns out to be all that was expected from the announcement. The hero is a pastor in the remote Norwegian mountains, and the author has painted his virtues, his failings, and the strange elements that made up his character with remarkable force. Though a brief work, it is a worthy companion to the author's earlier efforts."

Note that Example 3 only implies translation - the Norwegian author's work is being reviewed in English, and the "faithfully rendered" phrase in the title suggests translation. Even with minimal information, extract:
- IsTranslatedBookReview: true
- Translated_Title: "The Battle of Waterloo" (from the title)
- Author_Name: "Bjornson"
- Author_Nationality: "Norwegian"
- Source_Language: "Norwegian" (implied by "Norwegian mountains")
- Translation_Status: "recently published"
- Geographic_Focus: "Norway"
- Genre_Category: "Novel" (from title)

In historical reviews, the translation aspect is often understated or implicit. Unless the review is clearly about something other than a book written originally in a non-English language, assume it IS about a translated work and extract as much detail as possible.

Your task is to extract the following fields (use "Not Available" or "Not Mentioned" only when you cannot find or reasonably infer the information):

{
  "IsTranslatedBookReview": true,
  
  "Translated_Title": "The title of the translated book",
  "Original_Title": "Original title in source language (if mentioned)",
  "Author_Name": "Author of the original work",
  "Author_Nationality": "Nationality or country of origin",
  "Subject_Of_Work": "For biographies/non-fiction, the subject",
  "Translator_Name": "Name of the translator(s)",
  "Source_Language": "Language translated from",
  "Target_Language": "Language translated to (usually English)",
  
  "Translation_Publisher": "Publisher of the translation",
  "Translation_Status": "Status (forthcoming, recent, new edition, etc.)",
  "Edition_Information": "Edition details (first edition, authorized, etc.)",
  "Translation_Publication_Year": "Year of translation publication",
  "Original_Publication_Year": "Year of original publication",
  
  "Translation_Approach": "Approach mentioned (literal, free, adaptation)",
  "Translation_Quality_Comments": "Comments about quality of translation",
  "Cultural_Adaptation_Notes": "Notes about cultural adaptations",
  "Reception_Of_Translation": "Reception mentioned (positive/negative)",
  "Comparison_To_Original": "Any comparison to original work",
  "Translator_Visibility": "Prominence of translator (Not Mentioned, Mentioned, Prominently Featured)",
  "Paratextual_Elements": "Mentions of introductions, notes, glossaries, etc.",
  
  "Translator_Recognition": "Translator's reputation or credentials",
  "Translator_Previous_Works": "Translator's other works mentioned",
  "Author_Recognition": "Author's reputation or recognition",
  "Author_Previous_Works": "Author's other works mentioned",
  
  "Historical_Significance": "Historical importance mentioned",
  "Retranslation_Context": "If this is a retranslation",
  "Historical_Period": "Historical period of work",
  "Literary_Movement": "Literary movement if mentioned",
  "Geographic_Focus": "Geographic setting or focus",
  "Genre_Category": "Genre (novel, poetry, biography, etc.)",
  "Thematic_Elements": "Main themes if discussed",
  
  "Quoted_Passages_About_Translation": "Direct quotes about translation/translator",
  "Reviewer_Tone_Toward_Translation": "appreciative / dismissive / neutral / mixed / Not Mentioned",
  "Intertextual_References": "References to other works/translations",
  "Critical_Vocabulary_About_Translation": "Terms used to describe translation",
  "Translator_Framing_Strategy": "expert / mediator / invisible / problematic / co-author / Not Mentioned",
  "Sociopolitical_Commentary": "Political/social comments on translation",
  "Presence_Of_Reviewer_Multilingualism": "Yes / No / Not Mentioned"
}

BE EXHAUSTIVE and CREATIVE in your analysis, looking for both explicit and implicit information. Pay special attention to historical context, foreign-sounding names, and subtle references to translation. Even if translation is only implied (e.g., a book by a clearly foreign author reviewed in English), extract this information.

Look carefully through all the provided content (title, abstract, and full text) to find as much information as possible.

Output ONLY the JSON object with NO additional explanation.`;
    }
    
    // Display results in table format
    function displayResults() {
      if (processedData.length === 0) {
        resultsElement.innerHTML = '<p>No translated book reviews found in the dataset.</p>';
        return;
      }
      
      // Calculate extraction success statistics
      const extractionStats = {
        translatorName: processedData.filter(d => d.Translator_Name && d.Translator_Name !== "Not Available" && d.Translator_Name !== "Not Mentioned").length,
        sourceLanguage: processedData.filter(d => d.Source_Language && d.Source_Language !== "Not Available" && d.Source_Language !== "Not Mentioned").length,
        translatedTitle: processedData.filter(d => d.Translated_Title && d.Translated_Title !== "Not Available" && d.Translated_Title !== "Not Mentioned").length,
        authorName: processedData.filter(d => d.Author_Name && d.Author_Name !== "Not Available" && d.Author_Name !== "Not Mentioned").length,
        qualityComments: processedData.filter(d => d.Translation_Quality_Comments && d.Translation_Quality_Comments !== "Not Available" && d.Translation_Quality_Comments !== "Not Mentioned").length,
        genre: processedData.filter(d => d.Genre_Category && d.Genre_Category !== "Not Available" && d.Genre_Category !== "Not Mentioned").length,
        editionInfo: processedData.filter(d => d.Edition_Information && d.Edition_Information !== "Not Available" && d.Edition_Information !== "Not Mentioned").length,
        translatorRecognition: processedData.filter(d => d.Translator_Recognition && d.Translator_Recognition !== "Not Available" && d.Translator_Recognition !== "Not Mentioned").length,
        quotedPassages: processedData.filter(d => d.Quoted_Passages_About_Translation && d.Quoted_Passages_About_Translation !== "Not Available" && d.Quoted_Passages_About_Translation !== "Not Mentioned").length,
        translatorFraming: processedData.filter(d => d.Translator_Framing_Strategy && d.Translator_Framing_Strategy !== "Not Available" && d.Translator_Framing_Strategy !== "Not Mentioned").length
      };
      
      // Count review types
      const reviewTypeCount = {};
      processedData.forEach(record => {
        const type = record.Review_Type || "Other";
        reviewTypeCount[type] = (reviewTypeCount[type] || 0) + 1;
      });
      
      // Set filtered data to the full dataset initially
      filteredData = [...processedData];
      
      // Create results table
      resultsElement.innerHTML = createResultsTable(filteredData);
      
      // Create main results view
      const tableHTML = `
        <h3>Results: ${processedData.length} Translated Book Reviews Found</h3>
        
        <div class="info-box">
          <h4>Data Extraction Results</h4>
          <p>Successfully retrieved the following data:</p>
          <ul>
            <li>Translator Names: ${extractionStats.translatorName} records (${Math.round(extractionStats.translatorName/processedData.length*100)}%)</li>
            <li>Source Languages: ${extractionStats.sourceLanguage} records (${Math.round(extractionStats.sourceLanguage/processedData.length*100)}%)</li>
            <li>Translated Titles: ${extractionStats.translatedTitle} records (${Math.round(extractionStats.translatedTitle/processedData.length*100)}%)</li>
            <li>Author Names: ${extractionStats.authorName} records (${Math.round(extractionStats.authorName/processedData.length*100)}%)</li>
            <li>Translation Quality Comments: ${extractionStats.qualityComments} records (${Math.round(extractionStats.qualityComments/processedData.length*100)}%)</li>
            <li>Genre Identification: ${extractionStats.genre} records (${Math.round(extractionStats.genre/processedData.length*100)}%)</li>
            <li>Edition Information: ${extractionStats.editionInfo} records (${Math.round(extractionStats.editionInfo/processedData.length*100)}%)</li>
            <li>Translator Recognition: ${extractionStats.translatorRecognition} records (${Math.round(extractionStats.translatorRecognition/processedData.length*100)}%)</li>
            <li>Quoted Passages About Translation: ${extractionStats.quotedPassages} records (${Math.round(extractionStats.quotedPassages/processedData.length*100)}%)</li>
            <li>Translator Framing Analysis: ${extractionStats.translatorFraming} records (${Math.round(extractionStats.translatorFraming/processedData.length*100)}%)</li>
          </ul>
          
          <h4 style="margin-top: 15px;">Review Types:</h4>
          <ul>
      `;
      
      // Add review type statistics
      let typeHtml = '';
      Object.entries(reviewTypeCount).forEach(([type, count]) => {
        typeHtml += `<li>${type}: ${count} records (${Math.round(count/processedData.length*100)}%)</li>`;
      });
      
      let dataResultsElement = document.createElement('div');
      dataResultsElement.id = 'dataResults';
      dataResultsElement.innerHTML = tableHTML + typeHtml + `
          </ul>
        </div>
        
        <div style="margin: 20px 0;">
          <button id="downloadFinalExcelBtn" class="download-btn">Download as Excel</button>
          <button id="downloadFinalCSVBtn" class="download-btn">Download as CSV</button>
        </div>
      `;
      
      resultsElement.appendChild(dataResultsElement);
      
      // Add event listeners for download buttons
      document.getElementById('downloadFinalExcelBtn')?.addEventListener('click', downloadExcel);
      document.getElementById('downloadFinalCSVBtn')?.addEventListener('click', downloadCSV);
      
      // Initialize record selectors for validation and citation
      initializeRecordSelectors();
      
      // Set up clickable rows
      setupClickableRows();
      
      // Create custom field selection for export
      createCustomFieldSelection();
      
      // Create data dashboard
      createDataDashboard();
      
      // Show toast notification
      showToast(`Displaying ${processedData.length} processed records`, 'success');
    }
    
    // Create results table HTML
    function createResultsTable(data, limit = 15) {
      if (data.length === 0) {
        return '<p>No matching records found.</p>';
      }
      
      const displayCount = Math.min(limit, data.length);
      
      let tableHTML = `
        <h3>Showing ${displayCount} of ${data.length} Records</h3>
        <p class="help-text">Click on any row to view complete details for that review</p>
        <div style="overflow-x: auto;">
          <table>
            <thead>
              <tr>
                <th>Review Title</th>
                <th>Type</th>
                <th>Translated Title</th>
                <th>Author</th>
                <th>Translator</th>
                <th>Source Language</th>
                <th>Translation Status</th>
                <th>Genre</th>
              </tr>
            </thead>
            <tbody>
      `;
      
      // Add rows
      for (let i = 0; i < displayCount; i++) {
        const record = data[i];
        const typeClass = getReviewTypeClass(record.Review_Type);
        
        tableHTML += `
          <tr class="clickable-row" data-index="${processedData.indexOf(record)}">
            <td>${truncateText(record.Review_Title || "Not Available", 40)}</td>
            <td><span class="review-type-badge ${typeClass}">${record.Review_Type || "Other"}</span></td>
            <td>${truncateText(record.Translated_Title || "Not Available", 30)}</td>
            <td>${truncateText(record.Author_Name || "Not Available", 20)}</td>
            <td>${truncateText(record.Translator_Name || "Not Available", 20)}</td>
            <td>${record.Source_Language || "Not Available"}</td>
            <td>${record.Translation_Status || "Not Available"}</td>
            <td>${record.Genre_Category || "Not Available"}</td>
          </tr>
        `;
      }
      
      tableHTML += `
            </tbody>
          </table>
        </div>
        <p class="help-text">Showing ${displayCount} of ${data.length} records. Use search and filters to narrow down results.</p>
      `;
      
      return tableHTML;
    }
    
    // Setup clickable rows
    function setupClickableRows() {
      const rows = document.querySelectorAll('.clickable-row');
      rows.forEach(row => {
        row.addEventListener('click', function() {
          const index = this.getAttribute('data-index');
          showRecordDetails(index);
        });
      });
    }
    
    // Initialize record selectors for validation and citation
    function initializeRecordSelectors() {
      const validationSelect = document.getElementById('validationRecordSelect');
      const citationSelect = document.getElementById('citationRecord');
      
      if (!validationSelect || !citationSelect) return;
      
      // Clear existing options
      validationSelect.innerHTML = '<option value="">-- Select a record to validate --</option>';
      citationSelect.innerHTML = '<option value="">-- Select a record to cite --</option>';
      
      // Add options for each record
      processedData.forEach((record, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${record.Review_ID}: ${truncateText(record.Review_Title, 40)}`;
        
        const option2 = option.cloneNode(true);
        
        validationSelect.appendChild(option);
        citationSelect.appendChild(option2);
      });
    }
    
    // Create custom field selection for export
    function createCustomFieldSelection() {
      const container = document.getElementById('customFieldSelection');
      if (!container) return;
      
      container.innerHTML = '';
      
      // Add checkboxes for each field
      columnOrder.forEach(field => {
        const fieldName = field.replace(/_/g, ' ');
        
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = field;
        checkbox.style.width = 'auto';
        checkbox.style.marginRight = '8px';
        checkbox.checked = true;
        
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(fieldName));
        
        container.appendChild(label);
      });
    }
    
    // Show detailed record in modal
    function showRecordDetails(index) {
      const record = processedData[index];
      if (!record) return;
      
      const typeClass = getReviewTypeClass(record.Review_Type);
      
      // Generate HTML for all fields
      let fieldsHTML = '<table style="width:100%">';
      
      // Add review metadata
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">A: Review Information</th></tr>
        <tr><td style="font-weight:bold; width:40%; padding:8px; text-align:center;">Review ID</td><td style="padding:8px; text-align:center;">${record.Review_ID || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review Title</td><td style="padding:8px; text-align:center;">${record.Review_Title || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review Date</td><td style="padding:8px; text-align:center;">${record.Review_Date || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review Year</td><td style="padding:8px; text-align:center;">${record.Review_Year || "Not Available"}</td></tr>
        <tr>
          <td style="font-weight:bold; padding:8px; text-align:center;">Review Type</td>
          <td style="padding:8px; text-align:center;"><span class="review-type-badge ${typeClass}">${record.Review_Type || "Other"}</span></td>
        </tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review Author</td><td style="padding:8px; text-align:center;">${record.Review_Author || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review URL</td><td style="padding:8px; text-align:center;">${makeUrlClickable(record.Review_URL) || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Review Word Count</td><td style="padding:8px; text-align:center;">${record.Review_Word_Count || "0"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Mentions Translator in First Para</td><td style="padding:8px; text-align:center;">${record.Mentions_Translator_In_First_Paragraph || "No"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Mentions Translation in Title</td><td style="padding:8px; text-align:center;">${record.Mentions_Translation_In_Title || "No"}</td></tr>
      `;
      
      // Add confidence scores if available
      if (record._confidenceScores) {
        fieldsHTML += `<tr><td colspan="2" style="font-weight:bold; padding:8px; text-align:center; background-color:var(--accent-color);">AI Confidence Scores</td></tr>`;
        
        // Display overall confidence
        const avgConfidence = Object.values(record._confidenceScores).reduce((sum, val) => sum + val, 0) / Object.values(record._confidenceScores).length;
        const confidenceLevel = avgConfidence >= 0.8 ? 'High' : avgConfidence >= 0.5 ? 'Medium' : 'Low';
        const confidenceClass = avgConfidence >= 0.8 ? 'confidence-high' : avgConfidence >= 0.5 ? 'confidence-medium' : 'confidence-low';
        
        fieldsHTML += `
          <tr>
            <td style="font-weight:bold; padding:8px; text-align:center;">Overall Confidence</td>
            <td style="padding:8px; text-align:center;">
              <div class="confidence-meter">
                <div class="confidence-bar">
                  <div class="confidence-level ${confidenceClass}" style="width: ${avgConfidence * 100}%;"></div>
                </div>
                <span class="confidence-score">${confidenceLevel} (${Math.round(avgConfidence * 100)}%)</span>
              </div>
            </td>
          </tr>
        `;
      }
      
      // Add core translation information
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">B: Core Translation Information</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translated Title</td><td style="padding:8px; text-align:center;">${record.Translated_Title || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Original Title</td><td style="padding:8px; text-align:center;">${record.Original_Title || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Author</td><td style="padding:8px; text-align:center;">${record.Author_Name || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Author Nationality</td><td style="padding:8px; text-align:center;">${record.Author_Nationality || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Subject of Work</td><td style="padding:8px; text-align:center;">${record.Subject_Of_Work || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translator</td><td style="padding:8px; text-align:center;">${record.Translator_Name || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Source Language</td><td style="padding:8px; text-align:center;">${record.Source_Language || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Target Language</td><td style="padding:8px; text-align:center;">${record.Target_Language || "Not Available"}</td></tr>
      `;
      
      // Add publication details
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">C: Publication Details</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translation Publisher</td><td style="padding:8px; text-align:center;">${record.Translation_Publisher || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translation Status</td><td style="padding:8px; text-align:center;">${record.Translation_Status || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Edition Information</td><td style="padding:8px; text-align:center;">${record.Edition_Information || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translation Year</td><td style="padding:8px; text-align:center;">${record.Translation_Publication_Year || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Original Year</td><td style="padding:8px; text-align:center;">${record.Original_Publication_Year || "Not Available"}</td></tr>
      `;
      
      // Add translation analysis
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">D: Translation Analysis</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translation Approach</td><td style="padding:8px; text-align:center;">${record.Translation_Approach || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Quality Comments</td><td style="padding:8px; text-align:center;">${record.Translation_Quality_Comments || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Cultural Notes</td><td style="padding:8px; text-align:center;">${record.Cultural_Adaptation_Notes || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Reception</td><td style="padding:8px; text-align:center;">${record.Reception_Of_Translation || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Comparison to Original</td><td style="padding:8px; text-align:center;">${record.Comparison_To_Original || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translator Visibility</td><td style="padding:8px; text-align:center;">${record.Translator_Visibility || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Paratextual Elements</td><td style="padding:8px; text-align:center;">${record.Paratextual_Elements || "Not Available"}</td></tr>
      `;
      
      // Add translator and author context
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">E: Translator & Author Context</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translator Recognition</td><td style="padding:8px; text-align:center;">${record.Translator_Recognition || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translator Previous Works</td><td style="padding:8px; text-align:center;">${record.Translator_Previous_Works || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Author Recognition</td><td style="padding:8px; text-align:center;">${record.Author_Recognition || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Author Previous Works</td><td style="padding:8px; text-align:center;">${record.Author_Previous_Works || "Not Available"}</td></tr>
      `;
      
      // Add contextual information
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">F: Contextual Information</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Historical Significance</td><td style="padding:8px; text-align:center;">${record.Historical_Significance || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Retranslation Context</td><td style="padding:8px; text-align:center;">${record.Retranslation_Context || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Historical Period</td><td style="padding:8px; text-align:center;">${record.Historical_Period || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Literary Movement</td><td style="padding:8px; text-align:center;">${record.Literary_Movement || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Geographic Focus</td><td style="padding:8px; text-align:center;">${record.Geographic_Focus || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Genre</td><td style="padding:8px; text-align:center;">${record.Genre_Category || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Thematic Elements</td><td style="padding:8px; text-align:center;">${record.Thematic_Elements || "Not Available"}</td></tr>
      `;
      
      // Add textual and discursive features
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">G: Textual and Discursive Features</th></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Quoted Passages About Translation</td><td style="padding:8px; text-align:center;">${record.Quoted_Passages_About_Translation || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Reviewer Tone Toward Translation</td><td style="padding:8px; text-align:center;">${record.Reviewer_Tone_Toward_Translation || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Intertextual References</td><td style="padding:8px; text-align:center;">${record.Intertextual_References || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Critical Vocabulary About Translation</td><td style="padding:8px; text-align:center;">${record.Critical_Vocabulary_About_Translation || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Translator Framing Strategy</td><td style="padding:8px; text-align:center;">${record.Translator_Framing_Strategy || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Sociopolitical Commentary</td><td style="padding:8px; text-align:center;">${record.Sociopolitical_Commentary || "Not Available"}</td></tr>
        <tr><td style="font-weight:bold; padding:8px; text-align:center;">Presence of Reviewer Multilingualism</td><td style="padding:8px; text-align:center;">${record.Presence_Of_Reviewer_Multilingualism || "Not Available"}</td></tr>
      `;
      
      // Add abstract
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">Review Abstract</th></tr>
        <tr><td colspan="2" style="padding:12px; background-color:var(--card-background); text-align:center;">${record.Review_Abstract || "Not Available"}</td></tr>
      `;
      
      // Add review text
      fieldsHTML += `
        <tr><th colspan="2" style="background-color:var(--accent-color); text-align:center; padding:10px;">Full Review Text</th></tr>
        <tr><td colspan="2" style="padding:12px; background-color:var(--card-background); text-align:center;">${record.Review_Article_Text || "Not Available"}</td></tr>
      `;
      
      fieldsHTML += '</table>';
      
      // Add action buttons
      fieldsHTML += `
        <div style="margin-top: 20px; display: flex; gap: 10px;">
          <button id="validateThisBtn" data-index="${index}">Validate This Record</button>
          <button id="generateCitationForBtn" data-index="${index}">Generate Citation</button>
        </div>
      `;
      
      // Set modal content
      modalTitle.textContent = `Review Details: ${truncateText(record.Review_Title, 50)}`;
      modalContent.innerHTML = fieldsHTML;
      
      // Add event listeners for action buttons
      document.getElementById('validateThisBtn')?.addEventListener('click', function() {
        const recordIndex = this.getAttribute('data-index');
        document.getElementById('validationRecordSelect').value = recordIndex;
        loadRecordForValidation();
        modal.style.display = 'none';
        tabButtons[5].click(); // Switch to validation tab
      });
      
      document.getElementById('generateCitationForBtn')?.addEventListener('click', function() {
        const recordIndex = this.getAttribute('data-index');
        document.getElementById('citationRecord').value = recordIndex;
        generateCitation();
        modal.style.display = 'none';
        tabButtons[6].click(); // Switch to export tab
      });
      
      // Show the modal
      modal.style.display = "block";
    }
    
    // Apply search and filters
    function applyFilters() {
      const searchTerm = searchInput.value.toLowerCase();
      const filterType = filterField.value;
      const sortBy = sortField.value;
      
      // Filter data
      filteredData = processedData.filter(record => {
        if (!searchTerm) return true;
        
        if (filterType === 'all') {
          // Search in all text fields
          return Object.keys(record).some(key => {
            if (typeof record[key] === 'string') {
              return record[key].toLowerCase().includes(searchTerm);
            }
            return false;
          });
        } else {
          // Search in specific field
          const fieldValue = record[filterType];
          if (typeof fieldValue === 'string') {
            return fieldValue.toLowerCase().includes(searchTerm);
          }
          return false;
        }
      });
      
      // Sort data
      if (sortBy) {
        filteredData.sort((a, b) => {
          const valA = a[sortBy] || '';
          const valB = b[sortBy] || '';
          return valA.localeCompare(valB);
        });
      }
      
      // Update results
      resultsElement.innerHTML = createResultsTable(filteredData);
      setupClickableRows();
      
      // Show toast notification
      showToast(`Found ${filteredData.length} matching records`, 'info');
    }
    
    // Reset filters
    function resetFilters() {
      searchInput.value = '';
      filterField.value = 'all';
      sortField.value = 'Review_Date';
      
      filteredData = [...processedData];
      resultsElement.innerHTML = createResultsTable(filteredData);
      setupClickableRows();
      
      // Show toast notification
      showToast('Filters reset', 'info');
    }
    
    // Create data dashboard with visualizations
    function createDataDashboard() {
      if (processedData.length === 0) return;
      
      // Create statistics cards
      createStatCards();
      
      // Create charts
      createSourceLanguageChart();
      createReviewTypeChart();
      createTranslatorVisibilityChart();
      createYearlyTrendsChart();
    }
    
    // Create stat cards for the dashboard
    function createStatCards() {
      const statsContainer = document.getElementById('statsContainer');
      if (!statsContainer) return;
      
      statsContainer.innerHTML = '';
      
      // Count unique translators, authors, etc.
      const translators = new Set();
      const authors = new Set();
      const languages = new Set();
      const publishers = new Set();
      
      processedData.forEach(record => {
        if (record.Translator_Name && record.Translator_Name !== "Not Available" && record.Translator_Name !== "Not Mentioned") {
          translators.add(record.Translator_Name);
        }
        if (record.Author_Name && record.Author_Name !== "Not Available" && record.Author_Name !== "Not Mentioned") {
          authors.add(record.Author_Name);
        }
        if (record.Source_Language && record.Source_Language !== "Not Available" && record.Source_Language !== "Not Mentioned") {
          languages.add(record.Source_Language);
        }
        if (record.Translation_Publisher && record.Translation_Publisher !== "Not Available" && record.Translation_Publisher !== "Not Mentioned") {
          publishers.add(record.Translation_Publisher);
        }
      });
      
      // Create cards
      const statsData = [
        { label: 'Total Reviews', value: processedData.length },
        { label: 'Unique Translators', value: translators.size },
        { label: 'Unique Authors', value: authors.size },
        { label: 'Source Languages', value: languages.size },
        { label: 'Publishers', value: publishers.size }
      ];
      
      statsData.forEach(stat => {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
          <div class="stat-label">${stat.label}</div>
          <div class="stat-number">${stat.value}</div>
        `;
        statsContainer.appendChild(card);
      });
      
      // Make stat cards draggable
      addDragHandlers();
    }
    
    // Make stat cards reorderable
    function addDragHandlers() {
      const cards = statsContainer?.querySelectorAll('.stat-card');
      if (!cards) return;
      
      cards.forEach(card => {
        card.setAttribute('draggable', 'true');
        card.addEventListener('dragstart', handleDragStart);
        card.addEventListener('dragover', handleDragOver);
        card.addEventListener('drop', handleDrop);
        card.addEventListener('dragend', handleDragEnd);
      });
    }
    
    // Drag handlers for stat cards
    function handleDragStart(e) {
      this.style.opacity = '0.4';
      e.dataTransfer.effectAllowed = 'move';
      window.dragSrc = this;
    }
    
    function handleDragOver(e) {
      e.preventDefault();
      return false;
    }
    
    function handleDrop(e) {
      e.stopPropagation();
      if (window.dragSrc !== this) {
        const statsContainer = document.getElementById('statsContainer');
        if (statsContainer) {
          statsContainer.insertBefore(window.dragSrc, this);
        }
      }
      return false;
    }
    
    function handleDragEnd() {
      this.style.opacity = '1';
    }
    
    // Create source language chart
    function createSourceLanguageChart() {
      if (!sourceLangChart) return;
      
      // Count languages
      const langCounts = {};
      processedData.forEach(record => {
        const lang = record.Source_Language || "Unknown";
        if (lang !== "Not Available" && lang !== "Not Mentioned") {
          langCounts[lang] = (langCounts[lang] || 0) + 1;
        }
      });
      
      // Sort languages by count
      const sortedLangs = Object.keys(langCounts).sort((a, b) => langCounts[b] - langCounts[a]);
      
      // Limit to top 10 plus "Other"
      const topLangs = sortedLangs.slice(0, 10);
      const otherCount = sortedLangs.slice(10).reduce((sum, lang) => sum + langCounts[lang], 0);
      
      const labels = [...topLangs];
      const data = topLangs.map(lang => langCounts[lang]);
      
      if (otherCount > 0) {
        labels.push('Other');
        data.push(otherCount);
      }
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#ecf0f1' : '#333';
      const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      
      // Create or update chart
      if (chartInstances.sourceLang) {
        chartInstances.sourceLang.destroy();
      }
      
      chartInstances.sourceLang = new Chart(sourceLangChart, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Number of Reviews',
            data: data,
            backgroundColor: isDark ? '#3498db' : '#2980b9',
            borderColor: isDark ? '#2980b9' : '#1c6ea4',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Distribution by Source Language',
              font: {
                size: 16
              },
              color: textColor
            },
            legend: {
              display: false,
              labels: {
                color: textColor
              }
            }
          },
          scales: {
            x: {
              ticks: {
                color: textColor
              },
              grid: {
                color: gridColor
              }
            },
            y: {
              ticks: {
                color: textColor
              },
              grid: {
                color: gridColor
              },
              beginAtZero: true
            }
          }
        }
      });
    }
    
    // Create review type chart
    function createReviewTypeChart() {
      if (!reviewTypeChart) return;
      
      // Count review types
      const typeCounts = {};
      processedData.forEach(record => {
        const type = record.Review_Type || "Other";
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
      
      // Sort types by count
      const sortedTypes = Object.keys(typeCounts).sort((a, b) => typeCounts[b] - typeCounts[a]);
      
      const labels = sortedTypes;
      const data = sortedTypes.map(type => typeCounts[type]);
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#ecf0f1' : '#333';
      const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      
      // Generate colors for each type
      const typeColors = {
        'Full-Length Review': isDark ? '#3498db' : '#2980b9',
        'Short Notice': isDark ? '#2ecc71' : '#27ae60',
        'Announcement': isDark ? '#f39c12' : '#e67e22',
        'Opinion Editorial': isDark ? '#9b59b6' : '#8e44ad',
        'Author Interview': isDark ? '#1abc9c' : '#16a085',
        'Round-up': isDark ? '#e74c3c' : '#c0392b',
        'Other': isDark ? '#95a5a6' : '#7f8c8d'
      };
      
      const colors = labels.map(type => typeColors[type] || '#bdc3c7');
      
      // Create or update chart
      if (chartInstances.reviewType) {
        chartInstances.reviewType.destroy();
      }
      
      chartInstances.reviewType = new Chart(reviewTypeChart, {
        type: 'pie',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: colors,
            borderColor: isDark ? '#121212' : '#ffffff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Review Types',
              font: {
                size: 16
              },
              color: textColor
            },
            legend: {
              position: 'right',
              labels: {
                color: textColor
              }
            }
          }
        }
      });
    }
    
    // Create translator visibility chart
    function createTranslatorVisibilityChart() {
      if (!translatorVisibilityChart) return;
      
      // Count visibility categories
      const visibilityCounts = {
        'Prominently Featured': 0,
        'Mentioned': 0,
        'Not Mentioned': 0
      };
      
      processedData.forEach(record => {
        const visibility = record.Translator_Visibility || "Not Mentioned";
        if (visibilityCounts.hasOwnProperty(visibility)) {
          visibilityCounts[visibility]++;
        } else {
          visibilityCounts['Not Mentioned']++;
        }
      });
      
      const labels = Object.keys(visibilityCounts);
      const data = Object.values(visibilityCounts);
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#ecf0f1' : '#333';
      const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      
      // Colors for each category
      const colors = [
        isDark ? '#2ecc71' : '#27ae60',  // Prominently Featured
        isDark ? '#f39c12' : '#e67e22',  // Mentioned
        isDark ? '#95a5a6' : '#7f8c8d'   // Not Mentioned
      ];
      
      // Create or update chart
      if (chartInstances.translatorVisibility) {
        chartInstances.translatorVisibility.destroy();
      }
      
      chartInstances.translatorVisibility = new Chart(translatorVisibilityChart, {
        type: 'doughnut',
        data: {
          labels: labels,
          datasets: [{
            data: data,
            backgroundColor: colors,
            borderColor: isDark ? '#121212' : '#ffffff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Translator Visibility',
              font: {
                size: 16
              },
              color: textColor
            },
            legend: {
              position: 'right',
              labels: {
                color: textColor
              }
            }
          }
        }
      });
    }
    
    // Create yearly trends chart
    function createYearlyTrendsChart() {
      if (!yearlyTrendsChart) return;
      
      // Group by year and count
      const yearlyData = {};
      
      processedData.forEach(record => {
        if (record.Review_Year && record.Review_Year !== "Not Available" && record.Review_Year !== "Not Mentioned") {
          const year = parseInt(record.Review_Year);
          if (!isNaN(year) && year >= 1800 && year <= 2025) {
            yearlyData[year] = (yearlyData[year] || 0) + 1;
          }
        }
      });
      
      // Sort years
      const years = Object.keys(yearlyData).sort((a, b) => parseInt(a) - parseInt(b));
      const counts = years.map(year => yearlyData[year]);
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#ecf0f1' : '#333';
      const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      
      // Create or update chart
      if (chartInstances.yearlyTrends) {
        chartInstances.yearlyTrends.destroy();
      }
      
      chartInstances.yearlyTrends = new Chart(yearlyTrendsChart, {
        type: 'line',
        data: {
          labels: years,
          datasets: [{
            label: 'Number of Reviews',
            data: counts,
            borderColor: isDark ? '#3498db' : '#2980b9',
            backgroundColor: isDark ? 'rgba(52, 152, 219, 0.2)' : 'rgba(41, 128, 185, 0.2)',
            fill: true,
            tension: 0.4,
            pointRadius: 3,
            pointHoverRadius: 5
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Reviews by Year',
              font: {
                size: 16
              },
              color: textColor
            },
            legend: {
              display: false,
              labels: {
                color: textColor
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Year',
                color: textColor
              },
              ticks: {
                color: textColor,
                maxRotation: 45,
                minRotation: 45,
                callback: function(value, index, values) {
                  // Show fewer ticks for readability
                  const year = this.getLabelForValue(value);
                  if (years.length > 20) {
                    return index % 5 === 0 ? year : '';
                  }
                  return year;
                }
              },
              grid: {
                color: gridColor
              }
            },
            y: {
              title: {
                display: true,
                text: 'Number of Reviews',
                color: textColor
              },
              ticks: {
                color: textColor
              },
              grid: {
                color: gridColor
              },
              beginAtZero: true
            }
          }
        }
      });
    }
    
    // Function to highlight command palette item
    function highlightCmd() {
      const cmdList = document.getElementById('cmdList').querySelectorAll('li');
      cmdList.forEach((li, i) => li.classList.toggle('active', i === window.cmdIndex));
    }
    
    // Function to execute command from palette
    function executeCmd(cmd) {
      switch(cmd) {
        case 'upload': fileInput.click(); break;
        case 'start': startProcessingBtn.click(); break;
        case 'dashboard': document.querySelector('[data-tab="dashboard"]').click(); break;
        case 'timeline': document.querySelector('[data-tab="timeline"]').click(); break;
        case 'export': document.querySelector('[data-tab="export"]').click(); break;
      }
    }
    
    // Helper function to make URLs clickable
    function makeUrlClickable(url) {
      if (!url || url === "Not Available") return url;
      try {
        return `<a href="${url}" target="_blank" rel="noopener noreferrer" class="url-link">${truncateText(url, 60)}</a>`;
      } catch(e) {
        return url;
      }
    }
    
    // Helper function to truncate text
    function truncateText(text, maxLength) {
      if (!text || text === "Not Available") return text;
      return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = message;
      
      const toastContainer = document.getElementById('toastContainer');
      if (toastContainer) {
        toastContainer.appendChild(toast);
        
        // Remove toast after 4 seconds
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateY(-30px)';
          setTimeout(() => {
            toastContainer.removeChild(toast);
          }, 500);
        }, 3500);
      }
    }
    
    // Log to console function
    function logToConsole(message) {
      const timestamp = new Date().toLocaleTimeString();
      const logConsole = document.getElementById('logConsole');
      if (logConsole) {
        logConsole.innerHTML += `<br>> ${timestamp}: ${message}`;
        logConsole.scrollTop = logConsole.scrollHeight;
      }
    }
    
    // Download results as Excel
    function downloadExcel() {
      if (processedData.length === 0) {
        showToast('No data to download', 'warning');
        return;
      }
      
      try {
        // Filter and organize data according to column specifications
        const organizedData = processedData.map(record => {
          // Create a new object with the ordered columns
          const orderedRecord = {};
          
          // Add columns in the desired order, skipping excluded columns
          columnOrder.forEach(column => {
            if (!excludeColumns.includes(column)) {
              orderedRecord[column] = record[column] || "Not Available";
            }
          });
          
          return orderedRecord;
        });
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        
        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(organizedData);
        
        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, "Translated Book Reviews");
        
        // Generate file
        XLSX.writeFile(wb, "NYT_Translated_Book_Reviews.xlsx");
        
        showToast('Excel file downloaded successfully', 'success');
      } catch (error) {
        logToConsole("Error creating Excel file: " + error.message);
        showToast('Error creating Excel file: ' + error.message, 'error');
      }
    }
    
    // Download results as CSV
    function downloadCSV() {
      if (processedData.length === 0) {
        showToast('No data to download', 'warning');
        return;
      }
      
      try {
        // Filter and organize data according to column specifications
        const organizedData = processedData.map(record => {
          // Create a new object with the ordered columns
          const orderedRecord = {};
          
          // Add columns in the desired order, skipping excluded columns
          columnOrder.forEach(column => {
            if (!excludeColumns.includes(column)) {
              orderedRecord[column] = record[column] || "Not Available";
            }
          });
          
          return orderedRecord;
        });
        
        // Convert to CSV
        const ws = XLSX.utils.json_to_sheet(organizedData);
        const csv = XLSX.utils.sheet_to_csv(ws);
        
        // Create download link
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = "NYT_Translated_Book_Reviews.csv";
        link.click();
        
        // Clean up
        URL.revokeObjectURL(url);
        
        showToast('CSV file downloaded successfully', 'success');
      } catch (error) {
        logToConsole("Error creating CSV file: " + error.message);
        showToast('Error creating CSV file: ' + error.message, 'error');
      }
    }
    
    // Initialize the application
    function init() {
      try {
        // Initialize DOM elements
        if (!initDOMElements()) {
          console.error("Failed to initialize DOM elements");
          return;
        }
        
        // Auto-detect OS dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          themeSwitch.checked = true;
          toggleDarkMode();
        }

        // Initialize dark mode
        initializeTheme();
        
        // Initialize event listeners
        initEventListeners();
        
        // Set API key status
        apiKeyStatus.textContent = "API key loaded";
        apiKeyStatus.style.color = "var(--success-color)";
        
        // Initialize temperature value display
        temperatureValue.textContent = (parseInt(temperatureInput.value) / 10).toFixed(1);
        
        // Initialize model description
        document.getElementById('modelDesc').textContent = modelSelect.selectedOptions[0].dataset.description;
        
        // Drag-and-drop handlers
        const dragOverlay = document.getElementById('dragOverlay');
        window.addEventListener('dragover', e => { e.preventDefault(); dragOverlay.style.display = 'flex'; });
        window.addEventListener('dragleave', e => { e.preventDefault(); dragOverlay.style.display = 'none'; });
        window.addEventListener('drop', e => {
          e.preventDefault();
          dragOverlay.style.display = 'none';
          const file = e.dataTransfer.files[0];
          if (file) {
            fileInput.files = e.dataTransfer.files;
            handleFileUpload({ target: fileInput });
          }
        });
        
        // Command palette setup
        const cmdPalette = document.getElementById('cmdPalette');
        const cmdInput = document.getElementById('cmdInput');
        const cmdList = document.getElementById('cmdList').querySelectorAll('li');
        window.cmdIndex = 0;
        
        cmdInput?.addEventListener('keydown', e => {
          if (e.key === 'Escape') { cmdPalette.style.display = 'none'; cmdInput.value = ''; }
          if (e.key === 'ArrowDown') { window.cmdIndex = (window.cmdIndex + 1) % cmdList.length; highlightCmd(); }
          if (e.key === 'ArrowUp') { window.cmdIndex = (window.cmdIndex - 1 + cmdList.length) % cmdList.length; highlightCmd(); }
          if (e.key === 'Enter') {
            executeCmd(cmdList[window.cmdIndex].dataset.cmd);
            cmdPalette.style.display = 'none'; cmdInput.value = '';
          }
        });
        
        cmdList.forEach(li => {
          li.addEventListener('click', function() {
            executeCmd(this.dataset.cmd);
            cmdPalette.style.display = 'none';
            cmdInput.value = '';
          });
        });
        
        // Highlight active sidebar link
        const navLinks = document.querySelectorAll('.sidebar nav a');
        function setActiveLink() {
          const scrollPos = window.scrollY + 100;
          navLinks.forEach(link => {
            const section = document.querySelector(link.getAttribute('href'));
            if (section && section.offsetTop <= scrollPos && section.offsetTop + section.offsetHeight > scrollPos) {
              link.classList.add('active');
              link.setAttribute('aria-current', 'page');
            } else {
              link.classList.remove('active');
              link.removeAttribute('aria-current');
            }
          });
        }
        window.addEventListener('scroll', setActiveLink);
        // Initial highlight
        setActiveLink();
        
        // Show welcome message
        showToast('Welcome to TransCorpora!', 'info');
        
        // Log initialization
        logToConsole("TransCorpora initialized - Ready for corpus creation and analysis");
        logToConsole("Multiple file formats now supported: Excel, PDF, Word documents, and images");
        logToConsole("Enhanced error handling and robust data processing");
        
      } catch (error) {
        console.error("Initialization error:", error);
        logToConsole("Initialization error: " + error.message);
      }
    }

    // Helper function to generate random colors
    function getRandomColor() {
      const letters = '0123456789ABCDEF';
      let color = '#';
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      return color;
    }

    // Get color from palette based on index
    function getColorFromPalette(index) {
      // Check if we're in dark mode
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      // Define color palettes for light and dark mode
      const lightPalette = [
        '#3498db', '#2ecc71', '#e74c3c', '#f39c12', 
        '#9b59b6', '#1abc9c', '#34495e', '#e67e22'
      ];
      
      const darkPalette = [
        '#2980b9', '#27ae60', '#c0392b', '#d35400', 
        '#8e44ad', '#16a085', '#2c3e50', '#d35400'
      ];
      
      const palette = isDark ? darkPalette : lightPalette;
      return palette[index % palette.length];
    }

    // Helper function to convert hex to rgb
    function hexToRgb(hex) {
      // Remove # if present
      hex = hex.replace('#', '');
      
      // Parse the hex values
      const r = parseInt(hex.substring(0, 2), 16);
      const g = parseInt(hex.substring(2, 4), 16);
      const b = parseInt(hex.substring(4, 6), 16);
      
      return `${r}, ${g}, ${b}`;
    }

    // Implementation for reanalyzeForTimeline
    function reanalyzeForTimeline() {
      // Log that we're starting
      logToConsole("Using LLM API to re-analyze data for timeline visualization...");
      
      // Show loading indicator
      const timelineViz = document.getElementById('timelineViz');
      if (timelineViz) {
        timelineViz.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      }
      
      // Get the parameters from the UI
      const startYear = parseInt(document.getElementById('timelineStartYear').value);
      const endYear = parseInt(document.getElementById('timelineEndYear').value);
      const groupBy = document.getElementById('timelineGroupBy').value;
      
      // Format the data to send to the LLM
      const filteredData = processedData.filter(record => {
        const year = parseInt(record.Review_Year);
        return !isNaN(year) && year >= startYear && year <= endYear;
      });
      
      if (filteredData.length === 0) {
        logToConsole("No data available for the selected time period");
        showToast('No data available for the selected time period', 'error');
        // Reset the timeline visualization area
        if (timelineViz) {
          timelineViz.innerHTML = '<div class="info-box">No data available for the selected time period</div>';
        }
        return;
      }
      
      // Prepare the prompt for the LLM
      const prompt = createTimelineAnalysisPrompt(filteredData, groupBy, startYear, endYear);
      
      // Call the OpenAI API
      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: modelSelect.value,
          messages: [{"role": "user", "content": prompt}],
          temperature: 0.3
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(data => {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          });
        }
        return response.json();
      })
      .then(data => {
        // Parse the response from the LLM
        try {
          logToConsole("Received LLM response for timeline visualization");
          const result = JSON.parse(data.choices[0].message.content);
          // Use the result to create the visualization
          createTimelineVisualizationFromLLMData(result);
          showToast('Timeline visualization updated with AI analysis', 'success');
        } catch (error) {
          logToConsole("Error parsing LLM response: " + error.message);
          logToConsole("Raw response: " + data.choices[0].message.content.substring(0, 200) + "...");
          showToast('Error analyzing timeline data', 'error');
          // Fallback to standard visualization
          createTimelineVisualization();
        }
      })
      .catch(error => {
        logToConsole("API error: " + error.message);
        showToast('API error, falling back to standard visualization', 'error');
        // Fallback to standard visualization
        createTimelineVisualization();
      });
    }

    // Implementation for reanalyzeForNetwork
    function reanalyzeForNetwork() {
      // Log that we're starting
      logToConsole("Using LLM API to re-analyze data for network visualization...");
      
      // Show loading indicator
      const networkViz = document.getElementById('networkViz');
      if (networkViz) {
        networkViz.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      }
      
      // Get parameters from UI
      const networkType = document.getElementById('networkType').value;
      const minConnections = parseInt(document.getElementById('networkMinConnections').value);
      
      if (processedData.length === 0) {
        logToConsole("No data available for network visualization");
        showToast('No data available for network visualization', 'error');
        // Reset the network visualization area
        if (networkViz) {
          networkViz.innerHTML = '<div class="info-box">No data available for network visualization</div>';
        }
        return;
      }
      
      // Format data for LLM - we'll send a limited amount to avoid token limits
      // Choose a good sample size based on data - max 100 items
      const dataForLLM = processedData.length > 100 ? 
        processedData.slice(0, 100) : processedData;
      
      // Prepare the prompt
      const prompt = createNetworkAnalysisPrompt(dataForLLM, networkType, minConnections);
      
      // Call the OpenAI API
      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: modelSelect.value,
          messages: [{"role": "user", "content": prompt}],
          temperature: 0.3
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(data => {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          });
        }
        return response.json();
      })
      .then(data => {
        // Parse the response
        try {
          logToConsole("Received LLM response for network visualization");
          const result = JSON.parse(data.choices[0].message.content);
          // Use the result to create the visualization
          generateNetworkFromLLMData(result);
          showToast('Network visualization updated with AI analysis', 'success');
        } catch (error) {
          logToConsole("Error parsing LLM response: " + error.message);
          logToConsole("Raw response: " + data.choices[0].message.content.substring(0, 200) + "...");
          showToast('Error analyzing network data', 'error');
          // Fallback to standard visualization
          generateNetwork();
        }
      })
      .catch(error => {
        logToConsole("API error: " + error.message);
        showToast('API error, falling back to standard visualization', 'error');
        // Fallback to standard visualization
        generateNetwork();
      });
    }

    // Helper function to create the timeline analysis prompt
    function createTimelineAnalysisPrompt(data, groupBy, startYear, endYear) {
      // Determine what to extract based on groupBy
      let extractField;
      switch(groupBy) {
        case 'year':
          extractField = 'Review_Year';
          break;
        case 'decade':
          extractField = 'Review_Year';
          break;
        case 'source_language':
          extractField = 'Source_Language';
          break;
        case 'review_type':
          extractField = 'Review_Type';
          break;
        default:
          extractField = 'Review_Year';
      }
      
      // Create a simple analysis of the data to help the LLM
      let simpleAnalysis = {};
      
      // For decade grouping, we'll pre-calculate decades
      if (groupBy === 'decade') {
        data.forEach(record => {
          const year = parseInt(record.Review_Year);
          if (!isNaN(year)) {
            const decade = Math.floor(year / 10) * 10;
            const decadeKey = `${decade}s`;
            simpleAnalysis[decadeKey] = (simpleAnalysis[decadeKey] || 0) + 1;
          }
        });
      } 
      // For other groupings
      else {
        data.forEach(record => {
          const value = record[extractField] || 'Unknown';
          if (value !== 'Not Available' && value !== 'Not Mentioned') {
            simpleAnalysis[value] = (simpleAnalysis[value] || 0) + 1;
          }
        });
      }
      
      // Create a formatted summary of the data
      const dataSummary = Object.entries(simpleAnalysis)
        .sort((a, b) => b[1] - a[1]) // Sort by frequency
        .slice(0, 10) // Top 10 values
        .map(([key, count]) => `${key}: ${count} reviews`)
        .join('\n');
      
      return `You are an expert in data analysis for historical book reviews. 
    Please analyze this translated book review data and generate a timeline visualization focused on ${groupBy}.
    Generate a JSON structure that can be used with D3.js to create a timeline visualization.

    Data Summary:
    - Time period: ${startYear} to ${endYear}
    - Total reviews: ${data.length}
    - Grouping by: ${groupBy}

    Top values in the data:
    ${dataSummary}

    ${groupBy === 'decade' ? 'Note: For decade grouping, use decade labels like "1850s", "1860s", etc.' : ''}
    ${groupBy === 'source_language' ? 'Note: Group the less common languages (fewer than 3 occurrences) as "Other"' : ''}

    Return a JSON object in this format:
    {
      "timelineData": [
        {
          "key": "category name",
          "values": [
            {"date": "YYYY", "count": number},
            ...
          ]
        },
        ...
      ]
    }

    Do not include any explanations, only return the JSON object.`;
    }

    // Helper function to create the network analysis prompt
    function createNetworkAnalysisPrompt(data, networkType, minConnections) {
      // Determine what nodes and relationships to extract based on networkType
      let relationship, sourceField, targetField;
      switch(networkType) {
        case 'translator_author':
          relationship = "connections between translators and authors";
          sourceField = 'Translator_Name';
          targetField = 'Author_Name';
          break;
        case 'translator_publisher':
          relationship = "connections between translators and publishers";
          sourceField = 'Translator_Name';
          targetField = 'Translation_Publisher';
          break;
        case 'author_language':
          relationship = "connections between authors and source languages";
          sourceField = 'Author_Name';
          targetField = 'Source_Language';
          break;
        case 'translator_language':
          relationship = "connections between translators and source languages";
          sourceField = 'Translator_Name';
          targetField = 'Source_Language';
          break;
        default:
          relationship = "connections between translators and authors";
          sourceField = 'Translator_Name';
          targetField = 'Author_Name';
      }
      
      // Create a simple analysis of the connections to help the LLM
      const connections = {};
      let validConnectionCount = 0;
      
      data.forEach(record => {
        const source = record[sourceField];
        const target = record[targetField];
        
        if (source && target && 
            source !== 'Not Available' && source !== 'Not Mentioned' &&
            target !== 'Not Available' && target !== 'Not Mentioned') {
          const key = `${source}|||${target}`;
          connections[key] = (connections[key] || 0) + 1;
          if (connections[key] >= minConnections) {
            validConnectionCount++;
          }
        }
      });
      
      return `You are an expert in network analysis for historical book reviews.
    Please analyze this translated book review data and generate a network visualization showing ${relationship}.
    Generate a JSON structure that can be used with D3.js to create a force-directed graph.

    Analysis Parameters:
    - Network type: ${networkType} (${relationship})
    - Minimum connections: ${minConnections}
    - Total records analyzed: ${data.length}
    - Valid connections meeting minimum threshold: ${validConnectionCount}

    Return a JSON object in this format:
    {
      "nodes": [
        {"id": "name1", "group": 1, "type": "${sourceField.split('_')[0].toLowerCase()}"},
        {"id": "name2", "group": 2, "type": "${targetField.split('_')[0].toLowerCase()}"}
        ...
      ],
      "links": [
        {"source": "name1", "target": "name2", "value": number_of_connections},
        ...
      ]
    }

    Requirements:
    1. Only include connections that appear at least ${minConnections} times
    2. Limit the network to maximum 50 nodes for clear visualization
    3. Set "group" value to 1 for ${sourceField.split('_')[0].toLowerCase()} nodes and 2 for ${targetField.split('_')[0].toLowerCase()} nodes
    4. Include "type" field with value "${sourceField.split('_')[0].toLowerCase()}" or "${targetField.split('_')[0].toLowerCase()}" 

    Do not include any explanations, only return the JSON object.`;
    }

    // Function to create timeline visualization from LLM data
    function createTimelineVisualizationFromLLMData(data) {
      // First check if we have valid data
      if (!data || !data.timelineData || !Array.isArray(data.timelineData)) {
        logToConsole("Invalid timeline data from LLM");
        // Fallback to standard visualization
        createTimelineVisualization();
        return;
      }
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const textColor = isDark ? '#ecf0f1' : '#333';
      const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
      
      // Extract data for the chart
      const chartLabels = new Set();
      data.timelineData.forEach(series => {
        series.values.forEach(point => {
          chartLabels.add(point.date);
        });
      });
      
      // Convert to array and sort
      const sortedLabels = Array.from(chartLabels).sort();
      
      // Create datasets for Chart.js
      const chartDatasets = data.timelineData.map((series, index) => {
        // Create a map for quick lookup of values by date
        const valueMap = {};
        series.values.forEach(point => {
          valueMap[point.date] = point.count;
        });
        
        // Create the dataset with color from palette
        return {
          label: series.key,
          data: sortedLabels.map(date => valueMap[date] || 0),
          borderColor: getColorFromPalette(index),
          backgroundColor: `rgba(${hexToRgb(getColorFromPalette(index))}, 0.2)`,
          fill: false,
          tension: 0.4,
          pointRadius: 3,
          pointHoverRadius: 5
        };
      });
      
      // Render the chart
      const timelineChart = document.getElementById('timelineChart');
      if (!timelineChart) return;
      
      if (chartInstances.timeline) {
        chartInstances.timeline.destroy();
      }
      
      chartInstances.timeline = new Chart(timelineChart, {
        type: 'line',
        data: {
          labels: sortedLabels,
          datasets: chartDatasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: 'Historical Timeline Analysis',
              font: {
                size: 16
              },
              color: textColor
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: textColor
              }
            },
            tooltip: {
              mode: 'index',
              intersect: false
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Time Period',
                color: textColor
              },
              ticks: {
                color: textColor,
                maxRotation: 45,
                minRotation: 45
              },
              grid: {
                color: gridColor
              }
            },
            y: {
              title: {
                display: true,
                text: 'Number of Reviews',
                color: textColor
              },
              ticks: {
                color: textColor
              },
              grid: {
                color: gridColor
              },
              beginAtZero: true
            }
          }
        }
      });
      
      // Render D3 timeline visualization
      renderD3Timeline(data.timelineData);
    }

    // Function to render D3 timeline
    function renderD3Timeline(timelineData) {
      const timelineViz = document.getElementById('timelineViz');
      if (!timelineViz) return;
      
      // Clear previous content
      timelineViz.innerHTML = '';
      
      // Get dimensions
      const margin = {top: 20, right: 20, bottom: 50, left: 50};
      const width = timelineViz.clientWidth - margin.left - margin.right;
      const height = 300 - margin.top - margin.bottom;
      
      // Create SVG
      const svg = d3.select(timelineViz)
        .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', `translate(${margin.left},${margin.top})`);
      
      // Verify we have data
      if (!timelineData || timelineData.length === 0) {
        svg.append('text')
          .attr('x', width / 2)
          .attr('y', height / 2)
          .attr('text-anchor', 'middle')
          .text('No data available for visualization');
        return;
      }
      
      // Extract all dates and create x scale
      const allDates = [];
      timelineData.forEach(series => {
        series.values.forEach(point => {
          allDates.push(point.date);
        });
      });
      
      // Sort and remove duplicates
      const uniqueDates = [...new Set(allDates)].sort();
      
      // Create scales
      const xScale = d3.scaleBand()
        .domain(uniqueDates)
        .range([0, width])
        .padding(0.1);
      
      // Find max count for y scale
      let maxCount = 0;
      timelineData.forEach(series => {
        series.values.forEach(point => {
          if (point.count > maxCount) maxCount = point.count;
        });
      });
      
      const yScale = d3.scaleLinear()
        .domain([0, maxCount * 1.1]) // Add 10% padding at top
        .range([height, 0]);
      
      // Create color scale
      const colorScale = d3.scaleOrdinal()
        .domain(timelineData.map(d => d.key))
        .range(d3.schemeCategory10);
      
      // Add X axis
      svg.append('g')
        .attr('transform', `translate(0,${height})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .attr('transform', 'rotate(-45)')
        .style('text-anchor', 'end');
      
      // Add Y axis
      svg.append('g')
        .call(d3.axisLeft(yScale));
      
      // Add lines
      timelineData.forEach((series) => {
        // Create line
        const line = d3.line()
          .x(d => xScale(d.date) + xScale.bandwidth() / 2)
          .y(d => yScale(d.count))
          .curve(d3.curveMonotoneX);
        
        // Draw line
        svg.append('path')
          .datum(series.values)
          .attr('fill', 'none')
          .attr('stroke', colorScale(series.key))
          .attr('stroke-width', 2)
          .attr('d', line);
        
        // Add points
        svg.selectAll(`dot-${series.key}`)
          .data(series.values)
          .enter()
          .append('circle')
          .attr('cx', d => xScale(d.date) + xScale.bandwidth() / 2)
          .attr('cy', d => yScale(d.count))
          .attr('r', 4)
          .attr('fill', colorScale(series.key))
          .attr('stroke', 'white')
          .attr('stroke-width', 1);
      });
      
      // Add legend
      const legend = svg.append('g')
        .attr('font-family', 'sans-serif')
        .attr('font-size', 10)
        .attr('text-anchor', 'end')
        .selectAll('g')
        .data(timelineData)
        .enter().append('g')
        .attr('transform', (d, i) => `translate(0,${i * 20})`);
      
      legend.append('rect')
        .attr('x', width - 19)
        .attr('width', 19)
        .attr('height', 19)
        .attr('fill', d => colorScale(d.key));
      
      legend.append('text')
        .attr('x', width - 24)
        .attr('y', 9.5)
        .attr('dy', '0.32em')
        .text(d => d.key);
    }

    // Function to generate network from LLM data
    function generateNetworkFromLLMData(data) {
      // Verify we have valid data
      if (!data || !data.nodes || !data.links || !Array.isArray(data.nodes) || !Array.isArray(data.links)) {
        logToConsole("Invalid network data from LLM");
        // Fallback to standard visualization
        generateNetwork();
        return;
      }
      
      const networkViz = document.getElementById('networkViz');
      if (!networkViz) return;
      
      networkViz.innerHTML = '';
      
      // Get dimensions
      const width = networkViz.clientWidth;
      const height = networkViz.clientHeight || 500;
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const nodeColor1 = isDark ? '#3498db' : '#2980b9';
      const nodeColor2 = isDark ? '#e74c3c' : '#c0392b';
      const backgroundColor = isDark ? '#1e1e1e' : '#ffffff';
      const textColor = isDark ? '#ecf0f1' : '#333';
      
      // Define node colors based on group
      const nodeColors = {
        1: nodeColor1,
        2: nodeColor2
      };
      
      // Create SVG
      const svg = d3.select(networkViz)
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', [0, 0, width, height])
        .attr('style', `background-color: ${backgroundColor}; max-width: 100%; height: auto;`);
      
      // Create tooltip
      const tooltip = d3.select(networkViz)
        .append('div')
        .attr('class', 'tooltip')
        .style('opacity', 0)
        .style('position', 'absolute')
        .style('padding', '8px')
        .style('background-color', isDark ? 'rgba(0, 0, 0, 0.8)' : 'rgba(255, 255, 255, 0.8)')
        .style('border-radius', '4px')
        .style('pointer-events', 'none')
        .style('color', textColor)
        .style('box-shadow', '0 2px 5px rgba(0, 0, 0, 0.2)')
        .style('font-size', '12px');
      
      // Create force simulation
      const simulation = d3.forceSimulation(data.nodes)
        .force('link', d3.forceLink(data.links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-400))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(30));
      
      // Add links
      const link = svg.append('g')
        .selectAll('line')
        .data(data.links)
        .enter().append('line')
        .attr('stroke', isDark ? '#555' : '#999')
        .attr('stroke-opacity', 0.8)
        .attr('stroke-width', d => Math.sqrt(d.value));
      
      // Add nodes
      const node = svg.append('g')
        .selectAll('g')
        .data(data.nodes)
        .enter().append('g')
        .call(d3.drag()
          .on('start', dragstarted)
          .on('drag', dragged)
          .on('end', dragended))
        .on('mouseover', function(event, d) {
          d3.select(this).select('circle')
            .transition()
            .duration(200)
            .attr('r', d => 12 + Math.sqrt(getLinkCount(d.id) * 2));
          
          tooltip.transition()
            .duration(200)
            .style('opacity', 0.9);
          
          const connections = getConnections(d.id);
          const connectionText = connections.length > 0 ? 
            `<br/>Connections: ${connections.slice(0, 5).join(', ')}${connections.length > 5 ? '...' : ''}` : '';
          
          tooltip.html(`${d.id}<br/>Type: ${d.type}${connectionText}`)
            .style('left', (event.pageX + 10) + 'px')
            .style('top', (event.pageY - 28) + 'px');
        })
        .on('mouseout', function() {
          d3.select(this).select('circle')
            .transition()
            .duration(200)
            .attr('r', d => 6 + Math.sqrt(getLinkCount(d.id)));
          
          tooltip.transition()
            .duration(500)
            .style('opacity', 0);
        });
      
      // Add circles to nodes
      node.append('circle')
        .attr('r', d => 6 + Math.sqrt(getLinkCount(d.id)))
        .attr('fill', d => nodeColors[d.group] || '#999')
        .attr('stroke', '#fff')
        .attr('stroke-width', 1.5);
      
      // Add text labels to nodes
      node.append('text')
        .attr('dx', 12)
        .attr('dy', '.35em')
        .text(d => d.id)
        .style('font-size', '10px')
        .style('fill', textColor)
        .style('pointer-events', 'none')
        .each(function(d) {
          const text = d3.select(this);
          const words = d.id.split(' ');
          // For long names, only show first two words
          if (words.length > 2) {
            text.text(words.slice(0, 2).join(' ') + '...');
          }
        });
      
      // Set up tick handler
      simulation.on('tick', () => {
        link
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);
        
        node
          .attr('transform', d => {
            // Keep nodes within bounds
            d.x = Math.max(20, Math.min(width - 20, d.x));
            d.y = Math.max(20, Math.min(height - 20, d.y));
            return `translate(${d.x},${d.y})`;
          });
      });
      
      // Store network instance for later use
      networkInstance = simulation;
      
      // Helper function to count links for a node
      function getLinkCount(nodeId) {
        return data.links.filter(link => link.source.id === nodeId || link.target.id === nodeId).length;
      }
      
      // Helper function to get connections for a node
      function getConnections(nodeId) {
        const connections = [];
        data.links.forEach(link => {
          if (link.source.id === nodeId) {
            connections.push(link.target.id);
          } else if (link.target.id === nodeId) {
            connections.push(link.source.id);
          }
        });
        return connections;
      }
      
      // Drag functions
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }
      
      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }
      
      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }
    }

    // This function is for reanalyzing keyword data using LLM
    function reanalyzeForKeywords() {
      // Log that we're starting
      logToConsole("Using LLM API to re-analyze data for keyword cloud...");
      
      // Show loading indicator
      const keywordCloud = document.getElementById('keywordCloud');
      if (keywordCloud) {
        keywordCloud.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      }
      
      // Get parameters from UI
      const keywordField = document.getElementById('keywordField').value;
      const minFreq = parseInt(document.getElementById('keywordMinFreq').value);
      
      if (processedData.length === 0) {
        logToConsole("No data available for keyword analysis");
        showToast('No data available for keyword analysis', 'error');
        // Reset the keyword cloud area
        if (keywordCloud) {
          keywordCloud.innerHTML = '<div class="info-box">No data available for keyword analysis</div>';
        }
        return;
      }
      
      // Prepare data for LLM - combine all text from the selected field
      const allText = processedData
        .map(record => record[keywordField] || "")
        .filter(text => text && text !== "Not Available" && text !== "Not Mentioned")
        .join(" ");
      
      if (!allText) {
        logToConsole("No text data available in the selected field");
        showToast('No text data available in the selected field', 'error');
        // Reset the keyword cloud area
        if (keywordCloud) {
          keywordCloud.innerHTML = '<div class="info-box">No text data available in the selected field</div>';
        }
        return;
      }
      
      // Prepare the prompt
      const prompt = createKeywordAnalysisPrompt(allText, keywordField, minFreq);
      
      // Call the OpenAI API
      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: modelSelect.value,
          messages: [{"role": "user", "content": prompt}],
          temperature: 0.3
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(data => {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          });
        }
        return response.json();
      })
      .then(data => {
        // Parse the response
        try {
          logToConsole("Received LLM response for keyword analysis");
          const result = JSON.parse(data.choices[0].message.content);
          // Use the result to create the visualization
          generateKeywordCloudFromLLMData(result);
          showToast('Keyword cloud updated with AI analysis', 'success');
        } catch (error) {
          logToConsole("Error parsing LLM response: " + error.message);
          logToConsole("Raw response: " + data.choices[0].message.content.substring(0, 200) + "...");
          showToast('Error analyzing keywords', 'error');
          // Fallback to standard visualization
          generateKeywordCloud();
        }
      })
      .catch(error => {
        logToConsole("API error: " + error.message);
        showToast('API error, falling back to standard visualization', 'error');
        // Fallback to standard visualization
        generateKeywordCloud();
      });
    }

    // Helper function to create the keyword analysis prompt
    function createKeywordAnalysisPrompt(text, fieldName, minFreq) {
      // Format the field name for readability
      const formattedFieldName = fieldName.replace(/_/g, ' ').toLowerCase();
      
      return `You are an expert in text analysis for historical book reviews.
    Please analyze this text content from ${formattedFieldName} in translated book reviews.
    Extract the most significant keywords and their frequencies.

    Analysis Parameters:
    - Field analyzed: ${formattedFieldName}
    - Minimum frequency threshold: ${minFreq}
    - Focus on terminology related to translation, book reviews, and literary analysis

    Return a JSON object in this format:
    {
      "keywords": [
        {"text": "keyword1", "size": frequency, "category": "category_name"},
        {"text": "keyword2", "size": frequency, "category": "category_name"},
        ...
      ]
    }

    Requirements:
    1. Only include keywords with frequency greater than or equal to ${minFreq}
    2. Limit to maximum 50 keywords for clear visualization
    3. For "category", assign one of: "translation_term", "literary_term", "publisher", "genre", "quality", "cultural", "other"
    4. Normalize frequencies so the largest is 100 and others are scaled proportionally
    5. Focus on meaningful terms, not common words like "the", "and", etc.
    6. Combine variations of the same term (e.g., "translate", "translation", "translator")
    7. For multi-word terms, keep them together if they form a single concept

    Text to analyze:
    ${text.substring(0, 12000)}

    Do not include any explanations, only return the JSON object.`;
    }

    // Function to generate keyword cloud from LLM data
    function generateKeywordCloudFromLLMData(data) {
      // Verify we have valid data
      if (!data || !data.keywords || !Array.isArray(data.keywords)) {
        logToConsole("Invalid keyword data from LLM");
        // Fallback to standard visualization
        generateKeywordCloud();
        return;
      }
      
      const keywordCloud = document.getElementById('keywordCloud');
      if (!keywordCloud) return;
      
      keywordCloud.innerHTML = '';
      
      // Get dimensions
      const width = keywordCloud.clientWidth;
      const height = keywordCloud.clientHeight || 400;
      
      // Get theme colors
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      const backgroundColor = isDark ? '#1e1e1e' : '#ffffff';
      const textColor = isDark ? '#ecf0f1' : '#333';
      
      // Define category colors
      const categoryColors = {
        'translation_term': isDark ? '#3498db' : '#2980b9',
        'literary_term': isDark ? '#2ecc71' : '#27ae60',
        'publisher': isDark ? '#e74c3c' : '#c0392b',
        'genre': isDark ? '#9b59b6' : '#8e44ad',
        'quality': isDark ? '#f39c12' : '#e67e22',
        'cultural': isDark ? '#1abc9c' : '#16a085',
        'other': isDark ? '#95a5a6' : '#7f8c8d'
      };
      
      // Set up the layout
      const layout = d3.layout.cloud()
        .size([width, height])
        .words(data.keywords.map(d => ({
          text: d.text,
          size: d.size,
          category: d.category
        })))
        .padding(5)
        .rotate(() => ~~(Math.random() * 2) * 90)
        .fontSize(d => Math.sqrt(d.size) * 3) // Scale font size
        .on('end', draw);
      
      // Start the layout algorithm
      layout.start();
      
      // Draw the word cloud
      function draw(words) {
        const svg = d3.select(keywordCloud)
          .append('svg')
          .attr('width', layout.size()[0])
          .attr('height', layout.size()[1])
          .attr('viewBox', [0, 0, layout.size()[0], layout.size()[1]])
          .attr('style', `background-color: ${backgroundColor}; max-width: 100%; height: auto;`);
        
        const cloud = svg.append('g')
          .attr('transform', `translate(${layout.size()[0] / 2},${layout.size()[1] / 2})`)
          .selectAll('text')
          .data(words)
          .enter().append('text')
          .style('font-size', d => `${d.size}px`)
          .style('font-family', 'var(--font-sans, sans-serif)')
          .style('fill', d => categoryColors[d.category] || textColor)
          .attr('text-anchor', 'middle')
          .attr('transform', d => `translate(${d.x},${d.y}) rotate(${d.rotate})`)
          .text(d => d.text)
          .on('mouseover', function(event, d) {
            d3.select(this)
              .transition()
              .duration(200)
              .style('font-size', `${d.size * 1.2}px`)
              .style('cursor', 'pointer')
              .style('font-weight', 'bold');
          })
          .on('mouseout', function(event, d) {
            d3.select(this)
              .transition()
              .duration(200)
              .style('font-size', `${d.size}px`)
              .style('font-weight', 'normal');
          });
        
        // Add a legend
        const legend = svg.append('g')
          .attr('transform', `translate(20,20)`)
          .selectAll('g')
          .data(Object.entries(categoryColors))
          .enter().append('g')
          .attr('transform', (d, i) => `translate(0,${i * 20})`);
        
        legend.append('rect')
          .attr('width', 18)
          .attr('height', 18)
          .attr('fill', d => d[1]);
        
        legend.append('text')
          .attr('x', 24)
          .attr('y', 9)
          .attr('dy', '0.35em')
          .text(d => d[0].replace('_', ' '))
          .style('font-size', '12px')
          .style('fill', textColor);
      }
    }
    
    // Standard network visualization function without LLM
    function generateNetwork() {
      // Log that we're starting
      logToConsole("Generating network visualization from data...");
      
      // Get parameters from UI
      const networkType = document.getElementById('networkType').value;
      const minConnections = parseInt(document.getElementById('networkMinConnections').value);
      
      const networkViz = document.getElementById('networkViz');
      if (!networkViz) return;
      
      // Show loading indicator
      networkViz.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      
      // Process the data based on network type
      let relationship, sourceField, targetField;
      switch(networkType) {
        case 'translator_author':
          relationship = "Translator-Author Connections";
          sourceField = 'Translator_Name';
          targetField = 'Author_Name';
          break;
        case 'translator_publisher':
          relationship = "Translator-Publisher Connections";
          sourceField = 'Translator_Name';
          targetField = 'Translation_Publisher';
          break;
        case 'author_language':
          relationship = "Author-Language Connections";
          sourceField = 'Author_Name';
          targetField = 'Source_Language';
          break;
        case 'translator_language':
          relationship = "Translator-Language Connections";
          sourceField = 'Translator_Name';
          targetField = 'Source_Language';
          break;
        default:
          relationship = "Translator-Author Connections";
          sourceField = 'Translator_Name';
          targetField = 'Author_Name';
      }
      
      // Process the data to find connections
      const connections = {};
      const nodes = {};
      
      // Process each record
      processedData.forEach(record => {
        const source = record[sourceField];
        const target = record[targetField];
        
        // Skip if either field is missing or unavailable
        if (!source || !target || 
            source === 'Not Available' || source === 'Not Mentioned' ||
            target === 'Not Available' || target === 'Not Mentioned') {
          return;
        }
        
        // Create or increment connection
        const connectionKey = `${source}|||${target}`;
        connections[connectionKey] = (connections[connectionKey] || 0) + 1;
        
        // Only add to nodes if connection meets minimum threshold
        if (connections[connectionKey] >= minConnections) {
          // Add source node
          if (!nodes[source]) {
            nodes[source] = {
              id: source,
              group: 1,
              type: sourceField.split('_')[0].toLowerCase()
            };
          }
          
          // Add target node
          if (!nodes[target]) {
            nodes[target] = {
              id: target,
              group: 2,
              type: targetField.split('_')[0].toLowerCase()
            };
          }
        }
      });
      
      // Convert to arrays for D3
      const nodesArray = Object.values(nodes);
      const linksArray = [];
      
      // Add links that meet minimum connections
      for (const [key, value] of Object.entries(connections)) {
        if (value >= minConnections) {
          const [source, target] = key.split('|||');
          if (nodes[source] && nodes[target]) {
            linksArray.push({
              source: source,
              target: target,
              value: value
            });
          }
        }
      }
      
      // Limit to top 50 nodes if needed (for readability)
      let limitedNodes = nodesArray;
      let limitedLinks = linksArray;
      
      if (nodesArray.length > 50) {
        // Sort nodes by number of connections
        const nodeConnections = {};
        linksArray.forEach(link => {
          nodeConnections[link.source] = (nodeConnections[link.source] || 0) + link.value;
          nodeConnections[link.target] = (nodeConnections[link.target] || 0) + link.value;
        });
        
        // Sort and limit to top 50
        limitedNodes = nodesArray
          .sort((a, b) => (nodeConnections[b.id] || 0) - (nodeConnections[a.id] || 0))
          .slice(0, 50);
        
        // Get node IDs for filtering links
        const nodeIds = new Set(limitedNodes.map(node => node.id));
        
        // Filter links to only include filtered nodes
        limitedLinks = linksArray.filter(link => 
          nodeIds.has(link.source) && nodeIds.has(link.target)
        );
      }
      
      // Create network data
      const networkData = {
        nodes: limitedNodes,
        links: limitedLinks
      };
      
      // Check if we have data
      if (networkData.nodes.length === 0 || networkData.links.length === 0) {
        networkViz.innerHTML = `<div class="info-box">
          <h4>No Network Data</h4>
          <p>No connections found with the selected criteria. Try reducing the minimum connections threshold.</p>
        </div>`;
        return;
      }
      
      // Now use the network data to generate the visualization
      generateNetworkFromLLMData(networkData);
      
      // Show toast notification
      showToast(`Generated ${relationship} network with ${networkData.nodes.length} nodes and ${networkData.links.length} connections`, 'success');
    }

    // Function to generate the keyword cloud visualization
    function generateKeywordCloud() {
      // Log that we're starting
      logToConsole("Generating keyword cloud visualization from data...");
      
      // Get parameters from UI
      const keywordField = document.getElementById('keywordField').value;
      const minFreq = parseInt(document.getElementById('keywordMinFreq').value);
      
      const keywordCloud = document.getElementById('keywordCloud');
      if (!keywordCloud) return;
      
      // Show loading indicator
      keywordCloud.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      
      // Extract text from selected field
      const allText = processedData
        .map(record => record[keywordField] || "")
        .filter(text => text && text !== "Not Available" && text !== "Not Mentioned")
        .join(" ");
      
      if (!allText) {
        keywordCloud.innerHTML = '<div class="info-box">No text data available in the selected field</div>';
        return;
      }
      
      // Process text to find keywords
      const words = allText.toLowerCase()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, " ")
        .replace(/\s{2,}/g, " ")
        .trim()
        .split(" ");
      
      // Count word frequencies
      const wordCounts = {};
      words.forEach(word => {
        if (word.length > 3) { // Skip short words
          wordCounts[word] = (wordCounts[word] || 0) + 1;
        }
      });
      
      // Filter by minimum frequency
      const filteredWords = Object.entries(wordCounts)
        .filter(([word, count]) => count >= minFreq)
        .sort((a, b) => b[1] - a[1]) // Sort by frequency
        .slice(0, 50); // Limit to top 50
      
      // If no words meet criteria
      if (filteredWords.length === 0) {
        keywordCloud.innerHTML = '<div class="info-box">No keywords found matching the minimum frequency criteria</div>';
        return;
      }
      
      // Find max frequency for scaling
      const maxFreq = filteredWords[0][1];
      
      // Create data for visualization
      const keywordData = {
        keywords: filteredWords.map(([word, count], index) => ({
          text: word,
          size: Math.max(10, Math.floor((count / maxFreq) * 100)), // Scale to 10-100
          category: assignCategory(word, index)
        }))
      };
      
      // Generate visualization
      generateKeywordCloudFromLLMData(keywordData);
      
      // Show toast notification
      showToast(`Generated keyword cloud with ${keywordData.keywords.length} terms`, 'success');
      
      // Helper function to assign categories
      function assignCategory(word, index) {
        // Simple categorization logic - in a real implementation this would be more sophisticated
        const translationTerms = ['translation', 'translator', 'translated', 'language', 'original', 'version'];
        const literaryTerms = ['novel', 'book', 'story', 'author', 'writer', 'literature', 'literary'];
        const genreTerms = ['fiction', 'poetry', 'drama', 'biography', 'history', 'romance', 'adventure'];
        const qualityTerms = ['excellent', 'good', 'poor', 'faithful', 'accurate', 'fluent', 'readable'];
        const culturalTerms = ['culture', 'cultural', 'foreign', 'american', 'european', 'western', 'eastern'];
        
        if (translationTerms.some(term => word.includes(term))) return 'translation_term';
        if (literaryTerms.some(term => word.includes(term))) return 'literary_term';
        if (genreTerms.some(term => word.includes(term))) return 'genre';
        if (qualityTerms.some(term => word.includes(term))) return 'quality';
        if (culturalTerms.some(term => word.includes(term))) return 'cultural';
        
        // Rotate through categories for remaining words
        const categories = ['other', 'translation_term', 'literary_term', 'genre', 'quality', 'cultural'];
        return categories[index % categories.length];
      }
    }

    // Function to perform concordance search using LLM
    function performConcordanceSearch() {
      // Get the search term from the input
      const searchTerm = document.getElementById('concordanceInput').value.trim();
      const concordanceResults = document.getElementById('concordanceResults');
      
      // Validate input
      if (!searchTerm) {
        concordanceResults.innerHTML = '<p>Please enter a search term.</p>';
        return;
      }
      
      // Log that we're starting
      logToConsole(`Performing concordance search for term: "${searchTerm}"`);
      
      // Show loading indicator
      concordanceResults.innerHTML = '<div class="loader-container"><div class="loader"></div></div>';
      
      // Check if we should use LLM API for analysis
      if (document.getElementById('reanalysisCheckbox')?.checked) {
        // Use LLM for advanced analysis
        performLLMConcordanceSearch(searchTerm, concordanceResults);
      } else {
        // Use standard search
        performStandardConcordanceSearch(searchTerm, concordanceResults);
      }
    }

    // Perform concordance search using LLM
    function performLLMConcordanceSearch(searchTerm, resultElement) {
      logToConsole("Using LLM API for advanced concordance analysis...");
      
      // Find instances of the search term in the data
      const matchingContexts = [];
      
      // Look for the term in all reviews
      processedData.forEach(record => {
        const text = record.Review_Article_Text || "";
        
        // Skip if empty text or search term not found
        if (!text || !text.toLowerCase().includes(searchTerm.toLowerCase())) {
          return;
        }
        
        // Get context around the search term (simplified for the prompt)
        const contextSize = 100; // characters before and after
        const textLower = text.toLowerCase();
        const termLower = searchTerm.toLowerCase();
        
        let startIndex = 0;
        while (startIndex < textLower.length) {
          const termIndex = textLower.indexOf(termLower, startIndex);
          if (termIndex === -1) break;
          
          const contextStart = Math.max(0, termIndex - contextSize);
          const contextEnd = Math.min(text.length, termIndex + searchTerm.length + contextSize);
          const context = text.substring(contextStart, contextEnd);
          
          matchingContexts.push({
            reviewId: record.Review_ID,
            reviewTitle: record.Review_Title,
            context: context,
            year: record.Review_Year || "Unknown"
          });
          
          startIndex = termIndex + termLower.length;
          
          // Limit to 15 examples for the prompt
          if (matchingContexts.length >= 15) break;
        }
      });
      
      // If no matches found
      if (matchingContexts.length === 0) {
        resultElement.innerHTML = `<p>No occurrences found for "${searchTerm}".</p>`;
        return;
      }
      
      // Create the prompt for LLM
      const prompt = createConcordanceAnalysisPrompt(searchTerm, matchingContexts);
      
      // Call the OpenAI API
      fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: modelSelect.value,
          messages: [{"role": "user", "content": prompt}],
          temperature: 0.3
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(data => {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          });
        }
        return response.json();
      })
      .then(data => {
        try {
          logToConsole("Received LLM response for concordance analysis");
          const result = JSON.parse(data.choices[0].message.content);
          displayConcordanceResults(result, searchTerm, resultElement);
          showToast('Concordance analysis completed with LLM', 'success');
        } catch (error) {
          logToConsole("Error parsing LLM response: " + error.message);
          logToConsole("Raw response: " + data.choices[0].message.content.substring(0, 200) + "...");
          showToast('Error analyzing concordance data', 'error');
          // Fallback to standard search
          performStandardConcordanceSearch(searchTerm, resultElement);
        }
      })
      .catch(error => {
        logToConsole("API error: " + error.message);
        showToast('API error, falling back to standard search', 'error');
        // Fallback to standard search
        performStandardConcordanceSearch(searchTerm, resultElement);
      });
    }

    // Perform standard concordance search without LLM
    function performStandardConcordanceSearch(searchTerm, resultElement) {
      logToConsole("Performing standard concordance search...");
      
      // Find instances of the search term in the data
      const matchingContexts = [];
      
      // Look for the term in all reviews
      processedData.forEach(record => {
        const text = record.Review_Article_Text || "";
        
        // Skip if empty text or search term not found
        if (!text || !text.toLowerCase().includes(searchTerm.toLowerCase())) {
          return;
        }
        
        // Get context around the search term
        const contextSize = 100; // characters before and after
        const textLower = text.toLowerCase();
        const termLower = searchTerm.toLowerCase();
        
        let startIndex = 0;
        while (startIndex < textLower.length) {
          const termIndex = textLower.indexOf(termLower, startIndex);
          if (termIndex === -1) break;
          
          const contextStart = Math.max(0, termIndex - contextSize);
          const contextEnd = Math.min(text.length, termIndex + searchTerm.length + contextSize);
          const context = text.substring(contextStart, contextEnd);
          
          // Format the context to highlight the search term
          const formattedContext = highlightSearchTerm(context, searchTerm);
          
          matchingContexts.push({
            reviewId: record.Review_ID,
            reviewTitle: record.Review_Title,
            context: formattedContext,
            year: record.Review_Year || "Unknown"
          });
          
          startIndex = termIndex + termLower.length;
          
          // Limit results to keep performance reasonable
          if (matchingContexts.length >= 50) break;
        }
      });
      
      // Display the results
      if (matchingContexts.length === 0) {
        resultElement.innerHTML = `<p>No occurrences found for "${searchTerm}".</p>`;
        return;
      }
      
      // Sort by year (oldest to newest) if available
      matchingContexts.sort((a, b) => {
        const yearA = parseInt(a.year);
        const yearB = parseInt(b.year);
        if (isNaN(yearA) || isNaN(yearB)) return 0;
        return yearA - yearB;
      });
      
      // Create HTML for results
      let resultsHTML = `
        <h4>Found ${matchingContexts.length} occurrences of "${searchTerm}"</h4>
        <div class="concordance-items">
      `;
      
      matchingContexts.forEach((item, index) => {
        resultsHTML += `
          <div class="concordance-item">
            <div class="concordance-header">
              <strong>${item.reviewTitle}</strong> (${item.year}) - ${item.reviewId}
            </div>
            <div class="concordance-context">
              ...${item.context}...
            </div>
          </div>
        `;
      });
      
      resultsHTML += '</div>';
      resultElement.innerHTML = resultsHTML;
      
      // Show toast notification
      showToast(`Found ${matchingContexts.length} occurrences of "${searchTerm}"`, 'success');
    }

    // Helper function to create the concordance analysis prompt
    function createConcordanceAnalysisPrompt(searchTerm, matchingContexts) {
      // Create examples string
      const examplesString = matchingContexts.map(item => 
        `Example from "${item.reviewTitle}" (${item.year}):\n"${item.context}"`
      ).join('\n\n');
      
      return `You are an expert in textual analysis of historical book reviews. 
    Analyze these occurrences of the term "${searchTerm}" in translated book reviews from The New York Times.

    I'm providing ${matchingContexts.length} examples where this term appears in review texts.

    ${examplesString}

    Please analyze how the term "${searchTerm}" is used in these contexts and provide:

    1. A categorization of different ways the term is used
    2. A historical analysis of how usage changes over time (if apparent)
    3. Specific patterns in how the term relates to translation or literary criticism
    4. 5-10 representative examples with your analysis

    Return your analysis in this JSON format:
    {
      "summary": "Brief summary of overall findings",
      "usageCategories": [
        {
          "category": "Category name",
          "description": "Description of this usage category",
          "frequency": "Approximate frequency (e.g., 'common', 'rare')"
        }
      ],
      "historicalTrends": "Analysis of any historical trends in usage",
      "examples": [
        {
          "text": "The example text with term highlighted",
          "year": "Year of publication",
          "analysis": "Your analysis of this specific example"
        }
      ],
      "relationToTranslation": "Analysis of how this term relates to translation discourse"
    }

    Focus on insights relevant to translation studies and book review analysis.
    Do not include any explanations, only return the JSON object.`;
    }

    // Helper function to display concordance results from LLM
    function displayConcordanceResults(result, searchTerm, resultElement) {
      // Create HTML for results
      let resultsHTML = `
        <h4>Analysis of "${searchTerm}" in Translation Reviews</h4>
        <div class="info-box">
          <p><strong>Summary:</strong> ${result.summary}</p>
        </div>
        
        <h5>Usage Categories</h5>
        <div class="categories-container">
      `;
      
      // Add categories
      result.usageCategories.forEach(category => {
        resultsHTML += `
          <div class="category-item">
            <div class="category-name">${category.category}</div>
            <div class="category-desc">${category.description}</div>
            <div class="category-freq">Frequency: ${category.frequency}</div>
          </div>
        `;
      });
      
      resultsHTML += `
        </div>
        
        <h5>Historical Trends</h5>
        <div class="info-box">
          <p>${result.historicalTrends}</p>
        </div>
        
        <h5>Relation to Translation</h5>
        <div class="info-box">
          <p>${result.relationToTranslation}</p>
        </div>
        
        <h5>Representative Examples</h5>
        <div class="concordance-items">
      `;
      
      // Add examples
      result.examples.forEach(example => {
        resultsHTML += `
          <div class="concordance-item">
            <div class="concordance-header">
              <strong>From ${example.year}</strong>
            </div>
            <div class="concordance-context">
              "${example.text.replace(new RegExp(`(${searchTerm})`, 'gi'), '<span class="keyword-highlight">$1</span>')}"
            </div>
            <div class="concordance-analysis">
              <em>${example.analysis}</em>
            </div>
          </div>
        `;
      });
      
      resultsHTML += '</div>';
      
      // Add additional styles for the new elements
      resultsHTML += `
        <style>
          .categories-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
          }
          .category-item {
            flex: 1;
            min-width: 200px;
            background-color: var(--accent-color);
            border-radius: 4px;
            padding: 10px;
            border-left: 3px solid var(--secondary-color);
          }
          .category-name {
            font-weight: bold;
            margin-bottom: 5px;
          }
          .category-desc {
            font-size: 0.9em;
            margin-bottom: 5px;
          }
          .category-freq {
            font-size: 0.8em;
            font-style: italic;
          }
          .concordance-analysis {
            margin-top: 5px;
            color: var(--light-text);
          }
        </style>
      `;
      
      resultElement.innerHTML = resultsHTML;
    }

    // Helper function to highlight search term in context
    function highlightSearchTerm(context, searchTerm) {
      return context.replace(
        new RegExp(`(${searchTerm})`, 'gi'),
        '<span class="keyword-highlight">$1</span>'
      );
    }

    // Initialize the validation interface
    function initializeValidationInterface() {
      logToConsole("Initializing validation interface...");
      
      // Get the interface elements
      const validationInterface = document.getElementById('validationInterface');
      const validationRecordSelect = document.getElementById('validationRecordSelect');
      const confidenceThreshold = document.getElementById('confidenceThreshold');
      const saveValidationBtn = document.getElementById('saveValidationBtn');
      const skipValidationBtn = document.getElementById('skipValidationBtn');
      const bulkExportValidatedBtn = document.getElementById('bulkExportValidatedBtn');
      
      // Check if elements exist
      if (!validationInterface || !validationRecordSelect) {
        logToConsole("Error: Validation interface elements not found");
        return;
      }
      
      // Clear and populate the record select dropdown
      populateValidationRecordSelect(validationRecordSelect);
      
      // Enable the buttons
      saveValidationBtn.disabled = validationRecordSelect.value === "";
      skipValidationBtn.disabled = validationRecordSelect.value === "";
      bulkExportValidatedBtn.disabled = validatedRecords.size === 0;
    }

    // Populate the validation record select dropdown
    function populateValidationRecordSelect(selectElement) {
      // Clear existing options
      selectElement.innerHTML = '<option value="">-- Select a record to validate --</option>';
      
      // Add options for each record
      processedData.forEach((record, index) => {
        // Skip already validated records
        if (validatedRecords.has(record.Review_ID)) return;
        
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${record.Review_ID}: ${truncateText(record.Review_Title, 40)}`;
        selectElement.appendChild(option);
      });
    }

    // Load a record for validation
    function loadRecordForValidation() {
      const validationRecordSelect = document.getElementById('validationRecordSelect');
      const confidenceThreshold = document.getElementById('confidenceThreshold');
      const validationInterface = document.getElementById('validationInterface');
      const saveValidationBtn = document.getElementById('saveValidationBtn');
      const skipValidationBtn = document.getElementById('skipValidationBtn');
      
      // Check if elements exist
      if (!validationRecordSelect || !validationInterface) {
        logToConsole("Error: Validation interface elements not found");
        return;
      }
      
      // Get the selected record index
      const recordIndex = validationRecordSelect.value;
      if (!recordIndex) {
        validationInterface.innerHTML = '<p>Please select a record to validate.</p>';
        saveValidationBtn.disabled = true;
        skipValidationBtn.disabled = true;
        return;
      }
      
      // Enable the buttons
      saveValidationBtn.disabled = false;
      skipValidationBtn.disabled = false;
      
      // Get the record
      const record = processedData[recordIndex];
      if (!record) {
        validationInterface.innerHTML = '<p>Error: Record not found.</p>';
        return;
      }
      
      // Get confidence threshold
      const threshold = confidenceThreshold.value;
      
      // Create the validation form
      let formHTML = `
        <h3>Validating Record: ${record.Review_ID}</h3>
        <p class="help-text">Review and correct AI-extracted fields. Fields with lower confidence are highlighted.</p>
        
        <div class="validation-form">
      `;
      
      // Categories of fields to display
      const fieldCategories = [
        {
          title: "Core Translation Information",
          fields: ["Translated_Title", "Original_Title", "Author_Name", "Author_Nationality", "Translator_Name", "Source_Language"]
        },
        {
          title: "Publication Details",
          fields: ["Translation_Publisher", "Translation_Status", "Edition_Information", "Translation_Publication_Year"]
        },
        {
          title: "Translation Analysis",
          fields: ["Translation_Quality_Comments", "Translator_Visibility", "Reception_Of_Translation"]
        },
        {
          title: "Contextual Information",
          fields: ["Genre_Category", "Historical_Significance", "Geographic_Focus"]
        }
      ];
      
      // Add fields by category
      fieldCategories.forEach(category => {
        formHTML += `<h4>${category.title}</h4>`;
        
        category.fields.forEach(field => {
          // Get confidence score if available
          let confidence = 0.5; // Default medium confidence
          let showField = true;
          
          if (record._confidenceScores && record._confidenceScores[field]) {
            confidence = record._confidenceScores[field];
            
            // Filter by confidence threshold
            if (threshold === "low" && confidence > 0.4) showField = false;
            if (threshold === "medium" && confidence > 0.7) showField = false;
          }
          
          // Skip field if filtered out by threshold (unless showing all)
          if (threshold !== "all" && !showField) return;
          
          // Determine confidence level
          let confidenceLevel = "";
          let confidenceClass = "";
          if (confidence >= 0.8) {
            confidenceLevel = "High";
            confidenceClass = "confidence-high";
          } else if (confidence >= 0.5) {
            confidenceLevel = "Medium";
            confidenceClass = "confidence-medium";
          } else {
            confidenceLevel = "Low";
            confidenceClass = "confidence-low";
          }
          
          // Format the field label
          const fieldLabel = field.replace(/_/g, ' ');
          
          // Create the field input
          formHTML += `
            <div class="validation-field" data-field="${field}">
              <div class="validation-field-title">
                <label for="val_${field}">${fieldLabel}</label>
                <span class="validation-confidence ${confidenceClass}">${confidenceLevel}</span>
              </div>
              <input type="text" id="val_${field}" name="val_${field}" value="${record[field] || ""}" 
                data-original="${record[field] || ""}" ${confidenceLevel === "Low" ? 'style="background-color: rgba(231, 76, 60, 0.1);"' : ''}>
            </div>
          `;
        });
      });
      
      formHTML += `
        </div>
        
        <div class="info-box" style="margin-top: 20px;">
          <strong>Original Review Text:</strong>
          <div style="max-height: 300px; overflow-y: auto; margin-top: 10px; padding: 10px; background-color: var(--accent-color);">
            ${record.Review_Article_Text || "Not Available"}
          </div>
        </div>
      `;
      
      // Set the validation form HTML
      validationInterface.innerHTML = formHTML;
    }

    // Save validation changes
    function saveValidation() {
      const validationRecordSelect = document.getElementById('validationRecordSelect');
      const recordIndex = validationRecordSelect.value;
      
      if (!recordIndex) {
        showToast('No record selected for validation', 'error');
        return;
      }
      
      const record = processedData[recordIndex];
      if (!record) {
        showToast('Error: Record not found', 'error');
        return;
      }
      
      // Get all input fields in the validation form
      const inputFields = document.querySelectorAll('.validation-field input');
      
      // Track if any changes were made
      let changesDetected = false;
      
      // Check each field for changes
      inputFields.forEach(input => {
        const field = input.closest('.validation-field').dataset.field;
        const originalValue = input.dataset.original;
        const newValue = input.value;
        
        // Update the record if value changed
        if (originalValue !== newValue) {
          record[field] = newValue;
          changesDetected = true;
          logToConsole(`Updated field "${field}" from "${originalValue}" to "${newValue}"`);
        }
      });
      
      // Mark as validated
      validatedRecords.add(record.Review_ID);
      
      // Update buttons
      document.getElementById('bulkExportValidatedBtn').disabled = false;
      
      // Show success message
      if (changesDetected) {
        showToast('Record validated with changes', 'success');
      } else {
        showToast('Record validated (no changes made)', 'success');
      }
      
      // Move to next record
      loadNextRecord();
    }

    // Skip validation for current record
    function skipValidation() {
      // Just load the next record without saving
      loadNextRecord();
      showToast('Record skipped', 'info');
    }

    // Load the next record for validation
    function loadNextRecord() {
      const validationRecordSelect = document.getElementById('validationRecordSelect');
      
      // Refresh the select dropdown to remove validated records
      populateValidationRecordSelect(validationRecordSelect);
      
      // Check if there are more records to validate
      if (validationRecordSelect.options.length <= 1) {
        // No more records
        document.getElementById('validationInterface').innerHTML = '<div class="info-box"><h4>Validation Complete</h4><p>All records have been validated or skipped. You can export the validated records using the button below.</p></div>';
        validationRecordSelect.value = "";
        document.getElementById('saveValidationBtn').disabled = true;
        document.getElementById('skipValidationBtn').disabled = true;
        showToast('All records processed', 'success');
      } else {
        // Select the first record
        validationRecordSelect.value = validationRecordSelect.options[1].value;
        loadRecordForValidation();
      }
    }

    // Export validated records
    function exportValidatedRecords() {
      if (validatedRecords.size === 0) {
        showToast('No validated records to export', 'warning');
        return;
      }
      
      try {
        // Filter only validated records
        const validatedData = processedData.filter(record => validatedRecords.has(record.Review_ID));
        
        // Filter and organize data according to column specifications
        const organizedData = validatedData.map(record => {
          // Create a new object with the ordered columns
          const orderedRecord = {};
          
          // Add columns in the desired order, skipping excluded columns
          columnOrder.forEach(column => {
            if (!excludeColumns.includes(column)) {
              orderedRecord[column] = record[column] || "Not Available";
            }
          });
          
          return orderedRecord;
        });
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        
        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(organizedData);
        
        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, "Validated Records");
        
        // Generate file
        XLSX.writeFile(wb, "NYT_Validated_Records.xlsx");
        
        showToast(`Exported ${validatedData.length} validated records`, 'success');
      } catch (error) {
        logToConsole("Error exporting validated records: " + error.message);
        showToast('Error exporting records: ' + error.message, 'error');
      }
    }

    // Check if LLM validation is needed based on confidence scores
    function checkIfLLMValidationNeeded(record) {
      // If no confidence scores, assume validation needed
      if (!record._confidenceScores) {
        return true;
      }
      
      // Count low confidence fields
      let lowConfidenceCount = 0;
      for (const field in record._confidenceScores) {
        if (record._confidenceScores[field] < 0.5) {
          lowConfidenceCount++;
        }
      }
      
      // If more than 3 low confidence fields, suggest LLM validation
      return lowConfidenceCount > 3;
    }

    // Use LLM to suggest improvements to a record
    function validateRecordWithLLM(record) {
      // Only proceed if API key and record are valid
      if (!apiKey || !record) {
        return Promise.reject(new Error("Missing API key or record"));
      }
      
      // Log that we're starting
      logToConsole(`Using LLM API to validate record: ${record.Review_ID}`);
      
      // Create the prompt
      const prompt = createValidationPrompt(record);
      
      // Return a promise for the API call
      return fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: modelSelect.value,
          messages: [{"role": "user", "content": prompt}],
          temperature: 0.2
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.json().then(data => {
            throw new Error(`API error: ${data.error?.message || 'Unknown error'}`);
          });
        }
        return response.json();
      })
      .then(data => {
        // Parse the response
        try {
          const result = JSON.parse(data.choices[0].message.content);
          return result;
        } catch (error) {
          throw new Error("Error parsing LLM response: " + error.message);
        }
      });
    }

    // Create a prompt for LLM validation
    function createValidationPrompt(record) {
      return `You are an expert in translation studies and historical book reviews. 
    Please validate and suggest improvements for the metadata extracted from this New York Times book review.

    Original Review Title: ${record.Review_Title}
    Review Date: ${record.Review_Date}
    Review Text:
    ${record.Review_Article_Text ? record.Review_Article_Text.substring(0, 2000) + (record.Review_Article_Text.length > 2000 ? '...' : '') : 'Not Available'}

    Currently extracted metadata:
    - Translated_Title: ${record.Translated_Title || 'Not Available'}
    - Original_Title: ${record.Original_Title || 'Not Available'}
    - Author_Name: ${record.Author_Name || 'Not Available'}
    - Author_Nationality: ${record.Author_Nationality || 'Not Available'}
    - Translator_Name: ${record.Translator_Name || 'Not Available'}
    - Source_Language: ${record.Source_Language || 'Not Available'}
    - Translation_Publisher: ${record.Translation_Publisher || 'Not Available'}
    - Translation_Status: ${record.Translation_Status || 'Not Available'}
    - Edition_Information: ${record.Edition_Information || 'Not Available'}
    - Translation_Publication_Year: ${record.Translation_Publication_Year || 'Not Available'}
    - Translation_Quality_Comments: ${record.Translation_Quality_Comments || 'Not Available'}
    - Translator_Visibility: ${record.Translator_Visibility || 'Not Available'}
    - Genre_Category: ${record.Genre_Category || 'Not Available'}

    Please review the data and provide corrections or additions. Look for any inconsistencies, omitted information, or likely errors.

    Analyze the review text carefully to find any mentions of:
    1. The translator's name or involvement
    2. Comments about the quality of the translation
    3. Information about the author's nationality or the original language
    4. Publication details like publisher name or year

    Return a JSON object with your suggested corrections in this format:
    {
      "corrections": {
        "Translated_Title": "Corrected or verified title",
        "Original_Title": "Corrected or verified original title",
        ...other fields with corrections...
      },
      "confidence": {
        "Translated_Title": 0.9,
        "Original_Title": 0.7,
        ...confidence scores for your corrections (0.0-1.0)...
      },
      "explanation": "Brief explanation of your most significant corrections and reasoning"
    }

    Only include fields in "corrections" that need changes or verification. If a field is unclear or cannot be determined from the text, mark it as "Not Available" with a low confidence score. For fields that are correct, include them with a high confidence score.

    Ensure your corrections are based only on evidence from the review text, not speculation.`;
    }

    // Apply LLM validation suggestions to a record
    function applyLLMValidationSuggestions(record, suggestions) {
      if (!record || !suggestions || !suggestions.corrections) {
        return false;
      }
      
      // Track if any changes were made
      let changesDetected = false;
      
      // Apply corrections to fields
      for (const field in suggestions.corrections) {
        if (record.hasOwnProperty(field) && suggestions.corrections[field] !== record[field]) {
          // Log the change
          logToConsole(`LLM suggested change to ${field}: "${record[field]}" -> "${suggestions.corrections[field]}"`);
          
          // Update the record
          record[field] = suggestions.corrections[field];
          changesDetected = true;
        }
      }
      
      // Update confidence scores if available
      if (suggestions.confidence && !record._confidenceScores) {
        record._confidenceScores = {};
      }
      
      if (suggestions.confidence) {
        for (const field in suggestions.confidence) {
          if (record._confidenceScores) {
            record._confidenceScores[field] = suggestions.confidence[field];
          }
        }
      }
      
      return changesDetected;
    }

    // 1. Add this function to initialize the export options
    function initializeExportOptions() {
      logToConsole("Initializing export options...");
      
      // Populate citation record dropdown
      const citationSelect = document.getElementById('citationRecord');
      if (citationSelect) {
        // Clear existing options
        citationSelect.innerHTML = '<option value="">-- Select a record to cite --</option>';
        
        // Add options for each record
        processedData.forEach((record, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = `${record.Review_ID}: ${truncateText(record.Review_Title, 40)}`;
          citationSelect.appendChild(option);
        });
      }
      
      // Create custom field selection
      createCustomFieldSelection();
      
      // Set up event listeners
      document.getElementById('generateCitationBtn')?.addEventListener('click', generateCitation);
      document.getElementById('copyCitationBtn')?.addEventListener('click', copyCitation);
      document.getElementById('customExportBtn')?.addEventListener('click', exportCustomFields);
      document.getElementById('generateReportBtn')?.addEventListener('click', generateReport);
      document.getElementById('downloadReportBtn')?.addEventListener('click', downloadReport);
      
      // Toggle custom report options visibility
      document.getElementById('reportTemplate')?.addEventListener('change', function() {
        document.getElementById('customReportOptions').style.display = 
          this.value === 'custom' ? 'block' : 'none';
      });
    }

    // 2. Add missing export functionality functions
    function generateCitation() {
      const citationSelect = document.getElementById('citationRecord');
      const citationStyle = document.getElementById('citationStyle');
      const citationOutput = document.getElementById('citationOutput');
      
      if (!citationSelect.value) {
        showToast('Please select a record to cite', 'warning');
        return;
      }
      
      const record = processedData[citationSelect.value];
      if (!record) {
        showToast('Record not found', 'error');
        return;
      }
      
      // Generate citation based on style
      let citation = '';
      const style = citationStyle.value;
      
      switch (style) {
        case 'mla':
          citation = generateMLACitation(record);
          break;
        case 'apa':
          citation = generateAPACitation(record);
          break;
        case 'chicago':
          citation = generateChicagoCitation(record);
          break;
        case 'harvard':
          citation = generateHarvardCitation(record);
          break;
        default:
          citation = generateMLACitation(record);
      }
      
      citationOutput.textContent = citation;
      showToast('Citation generated', 'success');
    }

    function copyCitation() {
      const citationOutput = document.getElementById('citationOutput');
      const citation = citationOutput.textContent;
      
      if (!citation || citation === 'Citation will appear here.') {
        showToast('No citation to copy', 'warning');
        return;
      }
      
      // Copy to clipboard
      navigator.clipboard.writeText(citation)
        .then(() => {
          showToast('Citation copied to clipboard', 'success');
        })
        .catch(err => {
          console.error('Failed to copy citation: ', err);
          showToast('Failed to copy citation', 'error');
        });
    }

    function exportCustomFields() {
      // Get all selected fields
      const checkboxes = document.querySelectorAll('#customFieldSelection input:checked');
      const selectedFields = Array.from(checkboxes).map(cb => cb.value);
      
      if (selectedFields.length === 0) {
        showToast('Please select at least one field to export', 'warning');
        return;
      }
      
      try {
        // Filter data to include only selected fields
        const customData = processedData.map(record => {
          const customRecord = {};
          selectedFields.forEach(field => {
            customRecord[field] = record[field] || "Not Available";
          });
          return customRecord;
        });
        
        // Create workbook
        const wb = XLSX.utils.book_new();
        
        // Create worksheet
        const ws = XLSX.utils.json_to_sheet(customData);
        
        // Add worksheet to workbook
        XLSX.utils.book_append_sheet(wb, ws, "Custom Export");
        
        // Generate file
        XLSX.writeFile(wb, "NYT_Custom_Export.xlsx");
        
        showToast('Custom export created successfully', 'success');
      } catch (error) {
        logToConsole("Error creating custom export: " + error.message);
        showToast('Error creating custom export: ' + error.message, 'error');
      }
    }

    function generateReport() {
      const reportTemplate = document.getElementById('reportTemplate');
      const reportOutput = document.getElementById('reportOutput');
      
      if (processedData.length === 0) {
        reportOutput.innerHTML = '<div class="info-box">No data available for report generation</div>';
        return;
      }
      
      // Get template type
      const templateType = reportTemplate.value;
      
      // Generate report based on template
      let reportHTML = '';
      
      if (templateType === 'custom') {
        // Get custom options
        const reportTitle = document.getElementById('customReportTitle').value || 'Custom Report';
        const sectionCheckboxes = document.querySelectorAll('#customReportOptions input:checked');
        const selectedSections = Array.from(sectionCheckboxes).map(cb => cb.value);
        
        reportHTML = generateCustomReport(reportTitle, selectedSections);
      } else {
        // Generate standard report
        switch (templateType) {
          case 'overview':
            reportHTML = generateOverviewReport();
            break;
          case 'translators':
            reportHTML = generateTranslatorsReport();
            break;
          case 'languages':
            reportHTML = generateLanguagesReport();
            break;
          case 'timeline':
            reportHTML = generateTimelineReport();
            break;
          case 'publishers':
            reportHTML = generatePublishersReport();
            break;
          default:
            reportHTML = generateOverviewReport();
        }
      }
      
      // Display the report
      reportOutput.innerHTML = reportHTML;
      showToast('Report generated successfully', 'success');
    }

    function downloadReport() {
      const reportOutput = document.getElementById('reportOutput');
      const reportTemplate = document.getElementById('reportTemplate');
      
      if (!reportOutput.innerHTML || reportOutput.innerHTML === '<!-- Report content will be inserted here -->') {
        showToast('No report to download', 'warning');
        return;
      }
      
      try {
        // Get report type for filename
        const templateType = reportTemplate.value;
        let reportTitle = 'NYT_Translation_Report';
        
        if (templateType === 'custom') {
          reportTitle = document.getElementById('customReportTitle').value || 'Custom_Report';
          reportTitle = reportTitle.replace(/\s+/g, '_');
        } else {
          reportTitle = `NYT_${templateType.charAt(0).toUpperCase() + templateType.slice(1)}_Report`;
        }
        
        // Create HTML document
        const htmlContent = `
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>${reportTitle}</title>
            <style>
              body {
                font-family: Arial, sans-serif;
                line-height: 1.6;
                color: #333;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
              }
              h1, h2, h3, h4 {
                color: #1a3d5c;
              }
              table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
              }
              th, td {
                padding: 10px;
                border: 1px solid #ddd;
                text-align: left;
              }
              th {
                background-color: #1a3d5c;
                color: white;
              }
              .info-box {
                background-color: #f0f7ff;
                border-left: 4px solid #2980b9;
                padding: 15px;
                margin: 15px 0;
              }
            </style>
          </head>
          <body>
            <h1>${reportTitle.replace(/_/g, ' ')}</h1>
            <p>Generated on ${new Date().toLocaleDateString()} using TransCorpora</p>
            
            ${reportOutput.innerHTML}
            
            <footer>
              <p>Report generated by TransCorpora ¬© 2025</p>
            </footer>
          </body>
          </html>
        `;
        
        // Create download link
        const blob = new Blob([htmlContent], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${reportTitle}.html`;
        link.click();
        
        // Clean up
        URL.revokeObjectURL(url);
        
        showToast('Report downloaded successfully', 'success');
      } catch (error) {
        logToConsole("Error downloading report: " + error.message);
        showToast('Error downloading report: ' + error.message, 'error');
      }
    }

    // 3. Add helper functions for citation generation
    function generateMLACitation(record) {
      const translator = record.Translator_Name !== "Not Available" ? `Translated by ${record.Translator_Name}. ` : "";
      const publisher = record.Translation_Publisher !== "Not Available" ? record.Translation_Publisher : "Publisher unknown";
      const year = record.Translation_Publication_Year !== "Not Available" ? record.Translation_Publication_Year : "n.d.";
      
      return `${record.Author_Name !== "Not Available" ? record.Author_Name : "Author unknown"}. "${record.Translated_Title}." ${translator}${publisher}, ${year}.`;
    }

    function generateAPACitation(record) {
      const translator = record.Translator_Name !== "Not Available" ? ` (${record.Translator_Name}, Trans.).` : ".";
      const publisher = record.Translation_Publisher !== "Not Available" ? record.Translation_Publisher : "Publisher unknown";
      const year = record.Translation_Publication_Year !== "Not Available" ? `(${record.Translation_Publication_Year})` : "(n.d.)";
      
      return `${record.Author_Name !== "Not Available" ? record.Author_Name : "Unknown author"}. ${year}. ${record.Translated_Title}${translator} ${publisher}.`;
    }

    function generateChicagoCitation(record) {
      const translator = record.Translator_Name !== "Not Available" ? `Translated by ${record.Translator_Name}. ` : "";
      const publisher = record.Translation_Publisher !== "Not Available" ? record.Translation_Publisher : "Publisher unknown";
      const year = record.Translation_Publication_Year !== "Not Available" ? record.Translation_Publication_Year : "n.d.";
      
      return `${record.Author_Name !== "Not Available" ? record.Author_Name : "Unknown author"}. ${record.Translated_Title}. ${translator}${publisher}, ${year}.`;
    }

    function generateHarvardCitation(record) {
      const translator = record.Translator_Name !== "Not Available" ? `Translated by ${record.Translator_Name}. ` : "";
      const publisher = record.Translation_Publisher !== "Not Available" ? record.Translation_Publisher : "Publisher unknown";
      const year = record.Translation_Publication_Year !== "Not Available" ? record.Translation_Publication_Year : "n.d.";
      
      return `${record.Author_Name !== "Not Available" ? record.Author_Name : "Unknown author"} (${year}). ${record.Translated_Title}. ${translator}${publisher}.`;
    }

    // 4. Report generation helper functions
    function generateOverviewReport() {
      // Count statistics
      const totalReviews = processedData.length;
      const uniqueTranslators = new Set(processedData.map(r => r.Translator_Name).filter(n => n && n !== "Not Available")).size;
      const uniqueAuthors = new Set(processedData.map(r => r.Author_Name).filter(n => n && n !== "Not Available")).size;
      const uniqueLanguages = new Set(processedData.map(r => r.Source_Language).filter(l => l && l !== "Not Available")).size;
      
      // Get date range
      const years = processedData.map(r => parseInt(r.Review_Year)).filter(y => !isNaN(y));
      const minYear = years.length ? Math.min(...years) : "Unknown";
      const maxYear = years.length ? Math.max(...years) : "Unknown";
      
      return `
        <h2>Corpus Overview</h2>
        
        <div class="info-box">
          <p>This report provides an overview of the translated book reviews corpus from The New York Times.</p>
          <p><strong>Date Range:</strong> ${minYear} - ${maxYear}</p>
          <p><strong>Total Reviews:</strong> ${totalReviews}</p>
          <p><strong>Unique Translators:</strong> ${uniqueTranslators}</p>
          <p><strong>Unique Authors:</strong> ${uniqueAuthors}</p>
          <p><strong>Source Languages:</strong> ${uniqueLanguages}</p>
        </div>
        
        <h3>Review Types Distribution</h3>
        <p>This corpus contains various types of reviews, including full-length reviews, short notices, and announcements.</p>
        
        <table>
          <thead>
            <tr>
              <th>Review Type</th>
              <th>Count</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
            ${generateReviewTypeDistribution()}
          </tbody>
        </table>
        
        <h3>Top Source Languages</h3>
        <p>The most common source languages in the corpus:</p>
        
        <table>
          <thead>
            <tr>
              <th>Language</th>
              <th>Count</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
            ${generateLanguageDistribution()}
          </tbody>
        </table>
      `;
    }

    function generateReviewTypeDistribution() {
      // Count review types
      const typeCounts = {};
      processedData.forEach(record => {
        const type = record.Review_Type || "Other";
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
      
      // Sort by count
      const sortedTypes = Object.entries(typeCounts).sort((a, b) => b[1] - a[1]);
      
      // Generate table rows
      return sortedTypes.map(([type, count]) => {
        const percentage = ((count / processedData.length) * 100).toFixed(1);
        return `<tr><td>${type}</td><td>${count}</td><td>${percentage}%</td></tr>`;
      }).join('');
    }

    function generateLanguageDistribution() {
      // Count languages
      const langCounts = {};
      processedData.forEach(record => {
        const lang = record.Source_Language || "Unknown";
        if (lang !== "Not Available" && lang !== "Not Mentioned") {
          langCounts[lang] = (langCounts[lang] || 0) + 1;
        }
      });
      
      // Sort by count and limit to top 10
      const sortedLangs = Object.entries(langCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // Generate table rows
      return sortedLangs.map(([lang, count]) => {
        const percentage = ((count / processedData.length) * 100).toFixed(1);
        return `<tr><td>${lang}</td><td>${count}</td><td>${percentage}%</td></tr>`;
      }).join('');
    }

    // Report templates for other types
    function generateTranslatorsReport() {
      // This would have detailed analysis of translators
      return `
        <h2>Translators Summary</h2>
        
        <div class="info-box">
          <p>This report analyzes the translators mentioned in The New York Times book reviews.</p>
        </div>
        
        <h3>Top Translators by Number of Reviews</h3>
        <table>
          <thead>
            <tr>
              <th>Translator Name</th>
              <th>Number of Reviews</th>
              <th>Languages Translated</th>
            </tr>
          </thead>
          <tbody>
            ${generateTopTranslatorsTable()}
          </tbody>
        </table>
        
        <h3>Translator Visibility Analysis</h3>
        <p>How translators are represented in reviews:</p>
        
        <table>
          <thead>
            <tr>
              <th>Visibility Category</th>
              <th>Count</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
            ${generateTranslatorVisibilityTable()}
          </tbody>
        </table>
      `;
    }

    function generateTopTranslatorsTable() {
      // Count translator appearances
      const translatorCounts = {};
      const translatorLanguages = {};
      
      processedData.forEach(record => {
        const translator = record.Translator_Name;
        const language = record.Source_Language;
        
        if (translator && translator !== "Not Available" && translator !== "Not Mentioned") {
          translatorCounts[translator] = (translatorCounts[translator] || 0) + 1;
          
          if (language && language !== "Not Available" && language !== "Not Mentioned") {
            if (!translatorLanguages[translator]) {
              translatorLanguages[translator] = new Set();
            }
            translatorLanguages[translator].add(language);
          }
        }
      });
      
      // Sort by count and limit to top 10
      const topTranslators = Object.entries(translatorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      // Generate table rows
      return topTranslators.map(([translator, count]) => {
        const languages = translatorLanguages[translator] ? 
          Array.from(translatorLanguages[translator]).join(', ') : 
          'Unknown';
        
        return `<tr><td>${translator}</td><td>${count}</td><td>${languages}</td></tr>`;
      }).join('');
    }

    function generateTranslatorVisibilityTable() {
      // Count visibility categories
      const visibilityCounts = {
        'Prominently Featured': 0,
        'Mentioned': 0,
        'Not Mentioned': 0
      };
      
      processedData.forEach(record => {
        const visibility = record.Translator_Visibility || "Not Mentioned";
        visibilityCounts[visibility] = (visibilityCounts[visibility] || 0) + 1;
      });
      
      // Generate table rows
      return Object.entries(visibilityCounts).map(([category, count]) => {
        const percentage = ((count / processedData.length) * 100).toFixed(1);
        return `<tr><td>${category}</td><td>${count}</td><td>${percentage}%</td></tr>`;
      }).join('');
    }

    function generateLanguagesReport() {
      // Placeholder for language analysis report
      return `
        <h2>Source Languages Analysis</h2>
        
        <div class="info-box">
          <p>This report analyzes the source languages mentioned in The New York Times book reviews.</p>
        </div>
        
        <h3>Language Distribution</h3>
        <table>
          <thead>
            <tr>
              <th>Source Language</th>
              <th>Number of Reviews</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
            ${generateLanguageDistribution()}
          </tbody>
        </table>
        
        <h3>Top Authors by Language</h3>
        <p>The most frequently reviewed authors for major source languages:</p>
        
        ${generateTopAuthorsByLanguage()}
      `;
    }

    function generateTimelineReport() {
      // Placeholder for timeline report
      return `
        <h2>Historical Timeline Report</h2>
        
        <div class="info-box">
          <p>This report analyzes translation trends over time in The New York Times book reviews.</p>
        </div>
        
        <h3>Reviews by Decade</h3>
        <table>
          <thead>
            <tr>
              <th>Decade</th>
              <th>Number of Reviews</th>
              <th>Top Language</th>
              <th>Top Author</th>
            </tr>
          </thead>
          <tbody>
            ${generateReviewsByDecade()}
          </tbody>
        </table>
        
        <h3>Historical Trends</h3>
        <p>Analysis of how translation coverage has evolved over time:</p>
        
        <div class="info-box">
          <p>This corpus shows shifting patterns in translation coverage over time, with variations in the prominence of different source languages, translator visibility, and critical approaches to translation.</p>
        </div>
      `;
    }

    function generateReviewsByDecade() {
      // Group reviews by decade
      const decadeCounts = {};
      const decadeLanguages = {};
      const decadeAuthors = {};
      
      processedData.forEach(record => {
        if (record.Review_Year && record.Review_Year !== "Not Available") {
          const year = parseInt(record.Review_Year);
          if (!isNaN(year)) {
            const decade = Math.floor(year / 10) * 10;
            const decadeKey = `${decade}s`;
            
            // Count reviews per decade
            decadeCounts[decadeKey] = (decadeCounts[decadeKey] || 0) + 1;
            
            // Track languages per decade
            const language = record.Source_Language;
            if (language && language !== "Not Available" && language !== "Not Mentioned") {
              if (!decadeLanguages[decadeKey]) decadeLanguages[decadeKey] = {};
              decadeLanguages[decadeKey][language] = (decadeLanguages[decadeKey][language] || 0) + 1;
            }
            
            // Track authors per decade
            const author = record.Author_Name;
            if (author && author !== "Not Available" && author !== "Not Mentioned") {
              if (!decadeAuthors[decadeKey]) decadeAuthors[decadeKey] = {};
              decadeAuthors[decadeKey][author] = (decadeAuthors[decadeKey][author] || 0) + 1;
            }
          }
        }
      });
      
      // Sort decades chronologically
      const sortedDecades = Object.keys(decadeCounts).sort();
      
      // Generate table rows
      return sortedDecades.map(decade => {
        const count = decadeCounts[decade];
        
        // Find top language for the decade
        let topLanguage = "Unknown";
        if (decadeLanguages[decade]) {
          const languages = Object.entries(decadeLanguages[decade]).sort((a, b) => b[1] - a[1]);
          if (languages.length) topLanguage = languages[0][0];
        }
        
        // Find top author for the decade
        let topAuthor = "Unknown";
        if (decadeAuthors[decade]) {
          const authors = Object.entries(decadeAuthors[decade]).sort((a, b) => b[1] - a[1]);
          if (authors.length) topAuthor = authors[0][0];
        }
        
        return `<tr><td>${decade}</td><td>${count}</td><td>${topLanguage}</td><td>${topAuthor}</td></tr>`;
      }).join('');
    }

    function generatePublishersReport() {
      // Placeholder for publishers report
      return `
        <h2>Publishers Analysis</h2>
        
        <div class="info-box">
          <p>This report analyzes the publishers mentioned in The New York Times translated book reviews.</p>
        </div>
        
        <h3>Top Publishers</h3>
        <table>
          <thead>
            <tr>
              <th>Publisher</th>
              <th>Number of Reviews</th>
              <th>Percentage</th>
            </tr>
          </thead>
          <tbody>
            ${generatePublishersTable()}
          </tbody>
        </table>
      `;
    }

    function generatePublishersTable() {
      // Count publishers
      const publisherCounts = {};
      
      processedData.forEach(record => {
        const publisher = record.Translation_Publisher;
        if (publisher && publisher !== "Not Available" && publisher !== "Not Mentioned") {
          publisherCounts[publisher] = (publisherCounts[publisher] || 0) + 1;
        }
      });
      
      // Sort by count and limit to top 15
      const topPublishers = Object.entries(publisherCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);
      
      // Generate table rows
      return topPublishers.map(([publisher, count]) => {
        const percentage = ((count / processedData.length) * 100).toFixed(1);
        return `<tr><td>${publisher}</td><td>${count}</td><td>${percentage}%</td></tr>`;
      }).join('');
    }

    function generateTopAuthorsByLanguage() {
      // Group by major languages
      const languageAuthors = {};
      
      processedData.forEach(record => {
        const language = record.Source_Language;
        const author = record.Author_Name;
        
        if (language && language !== "Not Available" && language !== "Not Mentioned" &&
            author && author !== "Not Available" && author !== "Not Mentioned") {
          if (!languageAuthors[language]) languageAuthors[language] = {};
          languageAuthors[language][author] = (languageAuthors[language][author] || 0) + 1;
        }
      });
      
      // Sort languages by frequency
      const majorLanguages = Object.entries(languageAuthors)
        .sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length)
        .slice(0, 5);
      
      // Generate HTML
      let html = '';
      
      majorLanguages.forEach(([language, authors]) => {
        // Get top 5 authors for this language
        const topAuthors = Object.entries(authors)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 5);
        
        html += `
          <h4>${language}</h4>
          <ul>
            ${topAuthors.map(([author, count]) => `<li>${author} (${count} reviews)</li>`).join('')}
          </ul>
        `;
      });
      
      return html;
    }

    function generateCustomReport(title, sections) {
      let reportHTML = `
        <h2>${title}</h2>
        
        <div class="info-box">
          <p>This custom report analyzes The New York Times translated book reviews based on your selected criteria.</p>
        </div>
      `;
      
      // Add selected sections
      if (sections.includes('overview')) {
        reportHTML += `
          <h3>Corpus Overview</h3>
          <p>This corpus contains ${processedData.length} translated book reviews from The New York Times.</p>
          ${generateBasicStats()}
        `;
      }
      
      if (sections.includes('translators')) {
        reportHTML += `
          <h3>Translators Analysis</h3>
          <table>
            <thead>
              <tr>
                <th>Translator Name</th>
                <th>Number of Reviews</th>
              </tr>
            </thead>
            <tbody>
              ${generateTopTranslatorsTable()}
            </tbody>
          </table>
        `;
      }
      
      if (sections.includes('languages')) {
        reportHTML += `
          <h3>Source Languages</h3>
          <table>
            <thead>
              <tr>
                <th>Language</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody>
              ${generateLanguageDistribution()}
            </tbody>
          </table>
        `;
      }
      
      if (sections.includes('timeline')) {
        reportHTML += `
          <h3>Historical Timeline</h3>
          <table>
            <thead>
              <tr>
                <th>Decade</th>
                <th>Number of Reviews</th>
              </tr>
            </thead>
            <tbody>
              ${generateReviewsByDecade()}
            </tbody>
          </table>
        `;
      }
      
      if (sections.includes('publishers')) {
        reportHTML += `
          <h3>Publishers</h3>
          <table>
            <thead>
              <tr>
                <th>Publisher</th>
                <th>Number of Reviews</th>
              </tr>
            </thead>
            <tbody>
              ${generatePublishersTable()}
            </tbody>
          </table>
        `;
      }
      
      if (sections.includes('reception')) {
        reportHTML += `
          <h3>Reception Analysis</h3>
          <div class="info-box">
            <p>Analysis of how translations were received in reviews:</p>
            ${generateReceptionAnalysis()}
          </div>
        `;
      }
      
      return reportHTML;
    }

    function generateBasicStats() {
      // Calculate basic statistics
      const translatorCount = new Set(
        processedData
          .map(r => r.Translator_Name)
          .filter(t => t && t !== "Not Available" && t !== "Not Mentioned")
      ).size;
      
      const authorCount = new Set(
        processedData
          .map(r => r.Author_Name)
          .filter(a => a && a !== "Not Available" && a !== "Not Mentioned")
      ).size;
      
      const languageCount = new Set(
        processedData
          .map(r => r.Source_Language)
          .filter(l => l && l !== "Not Available" && l !== "Not Mentioned")
      ).size;
      
      return `
        <div class="info-box">
          <ul>
            <li><strong>Total Reviews:</strong> ${processedData.length}</li>
            <li><strong>Unique Translators:</strong> ${translatorCount}</li>
            <li><strong>Unique Authors:</strong> ${authorCount}</li>
            <li><strong>Source Languages:</strong> ${languageCount}</li>
          </ul>
        </div>
      `;
    }

    function generateReceptionAnalysis() {
      // Count reception categories
      const receptionCounts = {};
      
      processedData.forEach(record => {
        const reception = record.Reception_Of_Translation;
        if (reception && reception !== "Not Available" && reception !== "Not Mentioned") {
          // Simplify reception categories for analysis
          let category = "Neutral";
          
          if (reception.toLowerCase().includes("positive") || 
              reception.toLowerCase().includes("praise") ||
              reception.toLowerCase().includes("excellent") ||
              reception.toLowerCase().includes("good")) {
            category = "Positive";
          } else if (reception.toLowerCase().includes("negative") ||
                    reception.toLowerCase().includes("criticism") ||
                    reception.toLowerCase().includes("poor") ||
                    reception.toLowerCase().includes("awkward")) {
            category = "Negative";
          } else if (reception.toLowerCase().includes("mixed")) {
            category = "Mixed";
          }
          
          receptionCounts[category] = (receptionCounts[category] || 0) + 1;
        }
      });
      
      // Generate HTML
      return `
        <p><strong>Reception Categories:</strong></p>
        <ul>
          ${Object.entries(receptionCounts).map(([category, count]) => {
            const percentage = ((count / processedData.length) * 100).toFixed(1);
            return `<li>${category}: ${count} (${percentage}%)</li>`;
          }).join('')}
        </ul>
      `;
    }

   // Initialize the application
    window.addEventListener('DOMContentLoaded', init);
  
/* === Theme Selector === */
document.addEventListener('DOMContentLoaded', function() {
  const themeSelect = document.getElementById('backgroundThemeSelect');
  if (!themeSelect) return;
  // Set initial value
  const savedTheme = localStorage.getItem('theme') || 'light';
  themeSelect.value = savedTheme;
  // Ensure checkbox matches saved theme
  if (typeof themeSwitch !== 'undefined' && themeSwitch) {
    themeSwitch.checked = savedTheme === 'dark';
  }
  // Listen for changes
  themeSelect.addEventListener('change', function() {
    const selected = this.value;
    document.documentElement.setAttribute('data-theme', selected);
    localStorage.setItem('theme', selected);
    updateAllCharts();
    if (typeof themeSwitch !== 'undefined' && themeSwitch) {
      themeSwitch.checked = selected === 'dark';
    }
  });
});

/* === Dynamically update dataset colors based on --chart-colors === */
function applyChartColors(chart) {
  const style = getComputedStyle(document.documentElement);
  const palette = style.getPropertyValue('--chart-colors');
  if (!palette) return;
  const colors = palette.split(',').map(c => c.trim());
  chart.data.datasets.forEach((ds, idx) => {
    ds.backgroundColor = colors[idx % colors.length];
    ds.borderColor = colors[idx % colors.length];
  });
}
const originalUpdateAllCharts = updateAllCharts;
updateAllCharts = function() {
  originalUpdateAllCharts();
  // Re‚Äëapply dataset colors
  for (const chartId in chartInstances) {
    if (chartInstances[chartId]) {
      applyChartColors(chartInstances[chartId]);
      chartInstances[chartId].update();
    }
  }
};
</script>
</body>
</html>